<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Строение Атома (Модель Бора)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at center, #0b1021, #000000);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Панель информации */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(16, 20, 35, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 0 50px rgba(0, 100, 255, 0.2);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-left: 4px solid #00d2ff;
            z-index: 10;
            color: #d0d0d0;
        }

        #info-panel.active {
            transform: translateX(0);
        }

        #info-title {
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 22px;
            font-weight: 600;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            letter-spacing: 0.5px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        #info-desc {
            color: #b0c4de;
            font-size: 15px;
            line-height: 1.6;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: #666;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }

        .close-btn:hover {
            color: #fff;
        }

        /* Маркер элемента */
        #zone-label {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 10, 30, 0.8);
            color: #00d2ff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(0, 210, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.2);
        }

        /* Легенда цветов */
        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            color: #ccc;
            font-size: 13px;
            pointer-events: none;
            border: 1px solid #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            box-shadow: 0 0 5px currentColor;
        }
    </style>
</head>
<body>



<div id="canvas-container"></div>
<div id="zone-label">Частица</div>

<div id="legend">
    <div class="legend-item">
        <div class="dot" style="background:#ff3366; color:#ff3366"></div>
        Протон (+)
    </div>
    <div class="legend-item">
        <div class="dot" style="background:#3366ff; color:#3366ff"></div>
        Нейтрон (0)
    </div>
    <div class="legend-item">
        <div class="dot" style="background:#ffd700; color:#ffd700"></div>
        Электрон (-)
    </div>
</div>

<div id="info-panel">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="info-title">Название</h2>
    <p id="info-desc">Описание</p>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // --- ДАННЫЕ АТОМА ---
    const atomData = {
        "Proton": {
            title: "Протон (p⁺)",
            desc: "Положительно заряженная субатомная частица в ядре атома. Количество протонов определяет химический элемент (атомный номер). Масса протона примерно в 1836 раз больше массы электрона.",
            color: 0xff3366
        },
        "Neutron": {
            title: "Нейтрон (n⁰)",
            desc: "Нейтральная субатомная частица в ядре. Имеет массу, близкую к массе протона. Нейтроны стабилизируют ядро, удерживая протоны вместе за счет сильного ядерного взаимодействия, преодолевая их электростатическое отталкивание.",
            color: 0x3366ff
        },
        "Electron": {
            title: "Электрон (e⁻)",
            desc: "Легчайшая элементарная частица с отрицательным зарядом. Электроны движутся вокруг ядра по определенным орбитам (энергетическим уровням). Именно электроны участвуют в образовании химических связей.",
            color: 0xffd700
        },
        "Nucleus": {
            title: "Атомное ядро",
            desc: "Плотный центр атома, состоящий из нуклонов (протонов и нейтронов). Несмотря на то, что ядро занимает ничтожно малый объем по сравнению с размером атома, в нем сосредоточено более 99.9% всей массы атома.",
            color: 0xffffff
        },
        "Shell": {
            title: "Электронная оболочка",
            desc: "Энергетический уровень, на котором электроны вращаются вокруг ядра. По модели Бора электроны могут находиться только на определенных орбитах с фиксированной энергией.",
            color: 0x00d2ff
        }
    };

    // --- СЦЕНА ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // Легкий туман для глубины космоса
    scene.fog = new THREE.FogExp2(0x0b1021, 0.02);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 30);

    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    // Включаем bloom-эффект (симуляция через emissive materials)
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.5;
    container.appendChild(renderer.domElement);

    // --- ОСВЕЩЕНИЕ ---
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    // Свет из центра (ядро светится)
    const nucleusLight = new THREE.PointLight(0xffffff, 2, 50);
    nucleusLight.position.set(0, 0, 0);
    scene.add(nucleusLight);

    const blueLight = new THREE.DirectionalLight(0x0055ff, 1);
    blueLight.position.set(10, 10, 10);
    scene.add(blueLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    controls.maxDistance = 100;
    controls.minDistance = 5;

    // --- ГЕНЕРАЦИЯ АТОМА ---
    // Создадим атом углерода-12 (6 протонов, 6 нейтронов, 6 электронов)
    const PROTON_COUNT = 6;
    const NEUTRON_COUNT = 6;
    const ELECTRONS_CONFIG = [2, 4]; // 2 на K-оболочке, 4 на L-оболочке

    const atomGroup = new THREE.Group();
    scene.add(atomGroup);

    const nucleusGroup = new THREE.Group();
    atomGroup.add(nucleusGroup);

    // Материалы
    const protonMat = new THREE.MeshPhysicalMaterial({
        color: atomData.Proton.color,
        roughness: 0.2,
        metalness: 0.1,
        emissive: atomData.Proton.color,
        emissiveIntensity: 0.4,
        clearcoat: 1.0
    });

    const neutronMat = new THREE.MeshPhysicalMaterial({
        color: atomData.Neutron.color,
        roughness: 0.2,
        metalness: 0.1,
        emissive: atomData.Neutron.color,
        emissiveIntensity: 0.3,
        clearcoat: 1.0
    });

    const electronMat = new THREE.MeshBasicMaterial({
        color: atomData.Electron.color
    });

    // Свечение электрона (Sprite)
    const spriteMaterial = new THREE.SpriteMaterial({
        color: atomData.Electron.color,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    // Создаем текстуру для свечения программно
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 32;
    const context = canvas.getContext('2d');
    const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
    gradient.addColorStop(0.2, 'rgba(255, 215, 0, 1)');
    gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 32, 32);
    const glowTexture = new THREE.CanvasTexture(canvas);
    spriteMaterial.map = glowTexture;

    const particleGeo = new THREE.SphereGeometry(0.8, 32, 32);

    // --- 1. ЯДРО (Упаковка сфер) ---
    // Используем алгоритм фибоначчи или простую случайную упаковку с физикой отталкивания
    // Для простоты: случайное положение в сфере радиуса R

    const nucleons = [];
    const nucleusRadius = 2.5;

    function addNucleon(type) {
        const mesh = new THREE.Mesh(particleGeo, type === 'Proton' ? protonMat : neutronMat);

        // Пытаемся найти позицию, не пересекающуюся с другими
        let pos = new THREE.Vector3();
        let safe = false;
        let attempts = 0;

        while (!safe && attempts < 100) {
            pos.set(
                    (Math.random() - 0.5) * nucleusRadius,
                    (Math.random() - 0.5) * nucleusRadius,
                    (Math.random() - 0.5) * nucleusRadius
            );

            safe = true;
            for (let n of nucleons) {
                if (pos.distanceTo(n.position) < 1.4) { // 1.4 = чуть меньше 2*radius, чтобы они "слипались"
                    safe = false;
                    break;
                }
            }
            attempts++;
        }

        mesh.position.copy(pos);
        mesh.name = type;
        nucleusGroup.add(mesh);
        nucleons.push(mesh);
    }

    for (let i = 0; i < PROTON_COUNT; i++) addNucleon('Proton');
    for (let i = 0; i < NEUTRON_COUNT; i++) addNucleon('Neutron');

    // Центрируем ядро
    new THREE.Box3().setFromObject(nucleusGroup).getCenter(nucleusGroup.position).multiplyScalar(-1);


    // --- 2. ЭЛЕКТРОННЫЕ ОБОЛОЧКИ ---
    const electrons = [];
    const shellRadii = [6, 10, 15]; // Радиусы орбит

    ELECTRONS_CONFIG.forEach((count, shellIndex) => {
        const radius = shellRadii[shellIndex];

        // Визуализация орбиты (кольцо)
        const curve = new THREE.EllipseCurve(
                0, 0,            // ax, aY
                radius, radius,  // xRadius, yRadius
                0, 2 * Math.PI,  // aStartAngle, aEndAngle
                false,           // aClockwise
                0                // aRotation
        );
        const points = curve.getPoints(64);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({
            color: 0x00d2ff,
            transparent: true,
            opacity: 0.15
        });
        const orbit = new THREE.Line(geometry, material);
        orbit.rotation.x = Math.PI / 2; // Кладем горизонтально
        orbit.name = "Shell";
        atomGroup.add(orbit);

        // Создание электронов на этой оболочке
        for (let i = 0; i < count; i++) {
            // Равномерное распределение по углу
            const angle = (i / count) * Math.PI * 2;

            // Группа-контейнер для электрона (чтобы вращать группу, а не считать sin/cos каждый кадр)
            // Но для разнообразия наклона орбит сделаем индивидуальные пивоты
            const pivot = new THREE.Group();
            pivot.rotation.x = (Math.random() - 0.5) * 0.5; // Небольшой наклон орбиты
            pivot.rotation.y = (Math.random() - 0.5) * 0.5;

            // Сам электрон
            const electronGroup = new THREE.Group();

            const core = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), electronMat);
            electronGroup.add(core);

            const glow = new THREE.Sprite(spriteMaterial);
            glow.scale.set(3, 3, 1);
            electronGroup.add(glow);

            electronGroup.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            electronGroup.name = "Electron";

            pivot.add(electronGroup);
            atomGroup.add(pivot);

            electrons.push({
                obj: electronGroup,
                pivot: pivot,
                speed: (3 - shellIndex) * 0.5 + Math.random() * 0.2, // Внутренние быстрее
                angle: angle,
                radius: radius
            });
        }
    });

    // --- ИНТЕРАКТИВНОСТЬ ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let highlightedObj = null;

    const panel = document.getElementById('info-panel');
    const titleEl = document.getElementById('info-title');
    const descEl = document.getElementById('info-desc');
    const labelEl = document.getElementById('zone-label');

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onClick);

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Проверяем электроны и нуклоны. Орбиты игнорируем или обрабатываем отдельно.
        const intersects = raycaster.intersectObjects(scene.children, true);

        let found = null;
        for (let hit of intersects) {
            // Ищем объект с именем, которое есть в базе данных
            if (hit.object.name && atomData[hit.object.name]) {
                found = hit.object;
                break;
            }
        }

        if (found) {
            labelEl.textContent = atomData[found.name].title;
            labelEl.style.opacity = 1;
            document.body.style.cursor = 'pointer';
        } else {
            labelEl.style.opacity = 0;
            document.body.style.cursor = 'default';
        }
    }

    function onClick(event) {
        if (event.target.closest('#info-panel') || event.target.closest('.close-btn')) return;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        let found = null;
        for (let hit of intersects) {
            if (hit.object.name && atomData[hit.object.name]) {
                found = hit.object;
                break;
            }
        }

        if (found) {
            // Если кликнули на протон/нейтрон, считаем это кликом по Ядру,
            // но показываем инфо конкретной частицы
            showInfo(found.name);

            // Эффект выделения (пульсация или смена цвета - здесь просто логируем)
            if (highlightedObj && highlightedObj.material.emissive) {
                highlightedObj.material.emissiveIntensity = highlightedObj.userData.originalEmissive || 0.4;
            }

            highlightedObj = found;
            if (found.material.emissive) {
                found.userData.originalEmissive = found.material.emissiveIntensity;
                found.material.emissiveIntensity = 1.0;
            }

        } else {
            closePanel();
        }
    }

    function showInfo(key) {
        const data = atomData[key];
        titleEl.textContent = data.title;
        descEl.textContent = data.desc;

        const hexColor = '#' + data.color.toString(16).padStart(6, '0');
        panel.style.borderLeftColor = hexColor;
        panel.classList.add('active');
    }

    window.closePanel = function () {
        panel.classList.remove('active');
        if (highlightedObj && highlightedObj.material.emissive) {
            highlightedObj.material.emissiveIntensity = highlightedObj.userData.originalEmissive || 0.4;
            highlightedObj = null;
        }
    };

    // --- АНИМАЦИЯ ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const time = Date.now() * 0.001;

        // 1. Вибрация ядра (сильное взаимодействие)
        nucleusGroup.scale.setScalar(1 + Math.sin(time * 10) * 0.02);
        nucleusGroup.rotation.y = Math.sin(time * 0.5) * 0.1;
        nucleusGroup.rotation.z = Math.cos(time * 0.3) * 0.1;

        // 2. Вращение электронов
        electrons.forEach(e => {
            // Вращаем пивот (всю плоскость орбиты)
            // e.pivot.rotation.y += e.speed * 0.01;

            // Или двигаем электрон внутри группы по кругу (более предсказуемо для модели Бора)
            e.angle += e.speed * 0.02;
            e.obj.position.x = Math.cos(e.angle) * e.radius;
            e.obj.position.z = Math.sin(e.angle) * e.radius;

            // Пульсация свечения
            const glow = e.obj.children[1];
            if (glow) glow.material.opacity = 0.6 + Math.sin(time * 5 + e.angle) * 0.2;
        });

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>