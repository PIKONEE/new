<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анатомически Корректный Мозг</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at center, #1a1c20, #000000);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(25, 25, 25, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            border-left: 4px solid #e0c0c0;
            z-index: 10;
            color: #d0d0d0;
        }

        #info-panel.active {
            transform: translateX(0);
        }

        #info-title {
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 20px;
            font-weight: 600;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            letter-spacing: 0.5px;
        }

        #info-desc {
            color: #b0b0b0;
            font-size: 15px;
            line-height: 1.6;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: #666;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }

        .close-btn:hover {
            color: #fff;
        }

        #zone-label {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: #e0e0e0;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>

<div id="loading">Генерация коры головного мозга...</div>
<div id="canvas-container"></div>
<div id="zone-label">Зона мозга</div>

<div id="info-panel">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="info-title">Название</h2>
    <p id="info-desc">Описание</p>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // --- ДАННЫЕ О ЗОНАХ ---
    const brainZones = {
        "Frontal": {
            title: "Лобная доля (Lobus frontalis)",
            desc: "Самая крупная часть мозга (передняя часть). Отвечает за абстрактное мышление, планирование, контроль поведения, принятие решений и произвольные движения.",
            color: {r: 1.0, g: 0.4, b: 0.4} // Красный оттенок выделения
        },
        "Parietal": {
            title: "Теменная доля (Lobus parietalis)",
            desc: "Верхняя центральная часть. Обрабатывает сенсорную информацию (осязание, боль, температура), отвечает за пространственную ориентацию и интеграцию ощущений.",
            color: {r: 0.4, g: 0.6, b: 1.0} // Синий оттенок
        },
        "Occipital": {
            title: "Затылочная доля (Lobus occipitalis)",
            desc: "Задняя часть мозга. Первичный центр обработки зрительной информации: восприятие цвета, формы, движения и распознавание объектов.",
            color: {r: 1.0, g: 1.0, b: 0.4} // Желтый оттенок
        },
        "Temporal": {
            title: "Височная доля (Lobus temporalis)",
            desc: "Нижне-боковая часть. Отвечает за обработку слуха, восприятие речи, а также играет ключевую роль в формировании долговременной памяти и эмоций.",
            color: {r: 0.4, g: 1.0, b: 0.4} // Зеленый оттенок
        },
        "Cerebellum": {
            title: "Мозжечок (Cerebellum)",
            desc: "Расположен под затылочными долями. Не является частью коры больших полушарий. Критически важен для координации движений, равновесия и точности действий.",
            color: {r: 1.0, g: 0.6, b: 0.2} // Оранжевый
        }
    };

    const BASE_COLOR = new THREE.Color(0xccb8b4);

    // --- ЛОГИКА ОПРЕДЕЛЕНИЯ ЗОН (Математическая модель) ---
    // Используем локальные координаты вершины
    function getZoneFromLocalPoint(x, y, z) {
        // 1. Лобная доля (Передняя часть)
        if (z > 0.2 && y > -1.5) return "Frontal";

        // 2. Затылочная доля (Самая задняя)
        if (z < -1.8) return "Occipital";

        // 3. Височная доля (Нижняя боковая)
        if (y < -0.5 && z < 0.5 && z > -2.0) return "Temporal";

        // 4. Теменная доля (Остальное сверху)
        if (z <= 0.2 && z >= -1.8 && y >= -0.5) return "Parietal";

        return "Unknown";
    }

    // --- СЦЕНА ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 15, 0);

    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.SoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffeebb, 0.8);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xcceeff, 0.4);
    fillLight.position.set(-5, 0, -5);
    scene.add(fillLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 30;

    // --- МАТЕРИАЛЫ ---
    // Включаем vertexColors: true, чтобы красить вершины индивидуально
    const brainMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,  // ВАЖНО: Разрешаем разные цвета для разных зон
        roughness: 0.65,
        metalness: 0.05,
        flatShading: false
    });

    // Материал мозжечка (отдельный объект)
    const cerebellumMaterial = new THREE.MeshStandardMaterial({
        color: 0xbfaba7,
        roughness: 0.7,
        metalness: 0.0
    });

    // --- ГЕНЕРАЦИЯ ГЕОМЕТРИИ ---

    function createHemisphere(isLeft) {
        const geometry = new THREE.SphereGeometry(3, 128, 128);

        const pos = geometry.attributes.position;
        const count = pos.count;

        // Добавляем атрибут цвета и атрибут "ID зоны" для быстрого доступа
        const colors = new Float32Array(count * 3);
        const zoneIds = []; // Временный массив для хранения зоны вершины

        const temp = new THREE.Vector3();
        const normal = new THREE.Vector3();

        for (let i = 0; i < count; i++) {
            temp.fromBufferAttribute(pos, i);

            // --- 1. Формообразование (Анатомия) ---
            let x = temp.x * 0.85;
            let y = temp.y * 0.75;
            let z = temp.z * 1.0;

            const flattenFactor = 0.2;
            if (isLeft) {
                if (x > 0) x *= flattenFactor;
                x -= 0.15;
            } else {
                if (x < 0) x *= flattenFactor;
                x += 0.15;
            }

            const taper = (z < 0) ? (1.0 + z * 0.05) : 1.0;
            x *= (z > 0) ? 1.0 : 0.95;

            if (y < -1) y = -1 + (y + 1) * 0.5;

            // --- 2. Извилины (Шум) ---
            const freq = 1.8;
            const noise = Math.sin(x * freq + Math.cos(y * freq * 1.5)) +
                    Math.cos(z * freq + Math.sin(x * freq * 1.5)) +
                    Math.sin(y * freq + z * freq);
            const detail = Math.sin(x * 10) * 0.1;
            let displacement = (noise + detail) * 0.15;

            if (isLeft && temp.x > 0) displacement *= 0.1;
            if (!isLeft && temp.x < 0) displacement *= 0.1;
            if (temp.y < -2) displacement *= 0.2;

            temp.set(x, y, z);
            const hemisphereCenterX = isLeft ? -1.5 : 1.5;
            normal.set(x - hemisphereCenterX, y, z).normalize();
            temp.addScaledVector(normal, displacement);

            pos.setXYZ(i, temp.x, temp.y, temp.z);

            // --- 3. Определение Зоны и Цвета ---
            // Запоминаем, к какой зоне относится эта вершина
            const zone = getZoneFromLocalPoint(temp.x, temp.y, temp.z);
            zoneIds.push(zone);

            // Устанавливаем базовый цвет
            colors[i * 3] = BASE_COLOR.r;
            colors[i * 3 + 1] = BASE_COLOR.g;
            colors[i * 3 + 2] = BASE_COLOR.b;
        }

        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData = {zoneIds: zoneIds}; // Сохраняем IDs зон в данных геометрии для использования при клике

        geometry.computeVertexNormals();
        const mesh = new THREE.Mesh(geometry, brainMaterial.clone()); // Клонируем материал для независимости? Нет, лучше общий.
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.name = isLeft ? "LeftHemisphere" : "RightHemisphere";
        return mesh;
    }

    const brainGroup = new THREE.Group();
    scene.add(brainGroup);

    const leftHemi = createHemisphere(true);
    brainGroup.add(leftHemi);

    const rightHemi = createHemisphere(false);
    brainGroup.add(rightHemi);

    // --- МОЗЖЕЧОК ---
    const cerebGeo = new THREE.SphereGeometry(1.4, 64, 64);
    const cerebPos = cerebGeo.attributes.position;
    for (let i = 0; i < cerebPos.count; i++) {
        const y = cerebPos.getY(i);
        const z = cerebPos.getZ(i);
        const x = cerebPos.getX(i);
        let modX = x * 1.2;
        let modY = y * 0.6;
        let modZ = z * 0.7;
        const stripes = Math.sin(y * 20 + Math.sin(x * 2)) * 0.05;
        cerebPos.setXYZ(i, modX + x * stripes, modY + y * stripes, modZ + z * stripes);
    }
    cerebGeo.computeVertexNormals();
    const cerebellum = new THREE.Mesh(cerebGeo, cerebellumMaterial.clone());
    cerebellum.position.set(0, -1.8, -2.0);
    cerebellum.name = "CerebellumObj";
    brainGroup.add(cerebellum);

    // Ствол
    const stemGeo = new THREE.CylinderGeometry(0.8, 0.6, 2, 32);
    const stemMesh = new THREE.Mesh(stemGeo, cerebellumMaterial);
    stemMesh.position.set(0, -2.5, -0.5);
    stemMesh.rotation.x = 0.3;
    brainGroup.add(stemMesh);

    // --- ЛОГИКА ВЗАИМОДЕЙСТВИЯ И ВЫДЕЛЕНИЯ ---

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // UI Элементы
    const panel = document.getElementById('info-panel');
    const titleEl = document.getElementById('info-title');
    const descEl = document.getElementById('info-desc');
    const labelEl = document.getElementById('zone-label');
    let currentHighlightedZone = null;

    // Основная функция подсветки
    function highlightZone(zoneName) {
        if (currentHighlightedZone === zoneName) return; // Уже выделено
        currentHighlightedZone = zoneName;

        // 1. Обработка Полушарий (Vertex Colors)
        [leftHemi, rightHemi].forEach(mesh => {
            const colors = mesh.geometry.attributes.color;
            const zoneIds = mesh.geometry.userData.zoneIds;

            // Перебираем все вершины и красим нужные
            for (let i = 0; i < zoneIds.length; i++) {
                let targetColor = BASE_COLOR;

                // Если зона совпадает с запрашиваемой
                if (zoneIds[i] === zoneName && brainZones[zoneName]) {
                    // Используем цвет из конфига зоны
                    targetColor = brainZones[zoneName].color || {r: 1, g: 0, b: 0};

                    // Применяем цвет
                    colors.setXYZ(i, targetColor.r, targetColor.g, targetColor.b);
                } else {
                    // Сброс к базовому цвету
                    colors.setXYZ(i, BASE_COLOR.r, BASE_COLOR.g, BASE_COLOR.b);
                }
            }
            colors.needsUpdate = true;
        });

        // 2. Обработка Мозжечка (Отдельный материал)
        if (zoneName === "Cerebellum") {
            cerebellum.material.emissive.setHex(0x553311); // Подсветка
            cerebellum.material.color.setHex(0xffaa55);
        } else {
            cerebellum.material.emissive.setHex(0x000000); // Сброс
            cerebellum.material.color.setHex(0xbfaba7);
        }
    }

    function resetHighlight() {
        if (!currentHighlightedZone) return;
        highlightZone(null); // Сброс всех цветов
        currentHighlightedZone = null;
    }

    // Определение зоны под курсором
    function getHoveredZone(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(brainGroup.children);

        if (intersects.length > 0) {
            const hit = intersects[0];

            // Если попали в мозжечок
            if (hit.object.name === "CerebellumObj") {
                return "Cerebellum";
            }
            // Если попали в полушария
            else if (hit.object.name.includes("Hemisphere")) {
                // Переводим точку удара в локальные координаты объекта!
                // Это важно, так как модель вращается
                const localPoint = hit.object.worldToLocal(hit.point.clone());
                return getZoneFromLocalPoint(localPoint.x, localPoint.y, localPoint.z);
            }
        }
        return null;
    }

    window.addEventListener('mousemove', (event) => {
        const zone = getHoveredZone(event);
        if (zone && brainZones[zone]) {
            labelEl.textContent = brainZones[zone].title.split('(')[0];
            labelEl.style.opacity = 1;
            document.body.style.cursor = 'pointer';
        } else {
            labelEl.style.opacity = 0;
            document.body.style.cursor = 'default';
        }
    });

    window.addEventListener('click', (event) => {
        if (event.target.closest('#info-panel') || event.target.closest('.close-btn')) return;

        const zone = getHoveredZone(event);
        if (zone && brainZones[zone]) {
            showInfo(zone);
            highlightZone(zone);
        } else {
            closePanel();
            resetHighlight();
        }
    });

    function showInfo(zoneKey) {
        const data = brainZones[zoneKey];
        titleEl.textContent = data.title;
        descEl.textContent = data.desc;
        panel.classList.add('active');
    }

    window.closePanel = function () {
        panel.classList.remove('active');
        resetHighlight();
    };

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        brainGroup.rotation.y = Math.sin(Date.now() * 0.0005) * 0.05;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('loading').style.display = 'none';
    animate();

</script>
</body>
</html>