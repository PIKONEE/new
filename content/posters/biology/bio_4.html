<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Строение Клетки (Реалистичная)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at center, #0f172a, #000000);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Панель информации */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 340px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            border-left: 4px solid #38bdf8;
            z-index: 10;
            color: #e2e8f0;
        }

        #info-panel.active {
            transform: translateX(0);
        }

        #info-title {
            margin: 0 0 10px 0;
            color: #38bdf8;
            font-size: 24px;
            font-weight: 700;
            border-bottom: 1px solid #334155;
            padding-bottom: 12px;
            letter-spacing: 0.5px;
        }

        #info-desc {
            color: #94a3b8;
            font-size: 15px;
            line-height: 1.6;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: #64748b;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: #fff;
        }

        /* Маркер при наведении */
        #hover-label {
            position: absolute;
            top: 0;
            left: 0;
            background: rgba(15, 23, 42, 0.8);
            color: #38bdf8;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            transform: translate(20px, 0); /* Сдвиг вправо от курсора */
            border: 1px solid rgba(56, 189, 248, 0.3);
            white-space: nowrap;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }

        /* Линия-указатель от курсора (декор) */
        #hover-label::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 6px solid rgba(15, 23, 42, 0.8);
        }

        #main-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #f8fafc;
            font-family: 'Segoe UI', sans-serif;
            font-size: 26px;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-shadow: 0 0 30px rgba(56, 189, 248, 0.3);
            pointer-events: none;
            z-index: 5;
            text-align: center;
            width: 100%;
            background: linear-gradient(to right, transparent, rgba(15, 23, 42, 0.8), transparent);
            padding: 10px 0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #38bdf8;
            font-size: 14px;
            letter-spacing: 1px;
            font-weight: 500;
        }

    </style>
</head>
<body>

<h1 id="main-title">Клетка Человека (В разрезе)</h1>
<div id="loading">Синтез структуры...</div>

<div id="canvas-container"></div>
<div id="hover-label">Ядро</div>

<div id="info-panel">
    <button class="close-btn" onclick="closePanel()">&times;</button>
    <h2 id="info-title">Название</h2>
    <p id="info-desc">Описание</p>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // --- ДАННЫЕ ---
    const cellData = {
        "Membrane": {
            name: "Плазматическая мембрана",
            desc: "Внешняя граница клетки. На модели показана в разрезе. Это двойной слой липидов, который контролирует транспорт веществ и защищает внутреннее содержимое.",
            color: 0x60a5fa
        },
        "Cytoplasm": {
            name: "Цитозоль (Цитоплазма)",
            desc: "Полужидкая внутренняя среда. Здесь расположены органеллы и протекают основные метаболические реакции.",
            color: 0x94a3b8
        },
        "Nucleus": {
            name: "Клеточное ядро",
            desc: "Крупнейшая органелла. Содержит ДНК (хроматин). В центре видно ядрышко (более плотная область), где образуются рибосомы. Поверхность ядра покрыта порами.",
            color: 0xa855f7
        },
        "RoughER": {
            name: "Шероховатая ЭПС",
            desc: "Лабиринт из мембран, примыкающий к ядру. Называется «шероховатой» из-за множества рибосом на поверхности. Здесь синтезируются и сворачиваются белки.",
            color: 0xec4899
        },
        "SmoothER": {
            name: "Гладкая ЭПС",
            desc: "Сеть трубочек без рибосом. Отвечает за синтез липидов (жиров), обезвреживание токсинов и запас ионов кальция.",
            color: 0xf472b6
        },
        "Mitochondria": {
            name: "Митохондрия",
            desc: "Двумембранная органелла. Внутри видны складки (кристы). Генерирует энергию (АТФ) для клетки через клеточное дыхание.",
            color: 0xf97316
        },
        "Golgi": {
            name: "Аппарат Гольджи",
            desc: "Система плоских цистерн. Здесь белки сортируются, модифицируются и упаковываются в везикулы для отправки в нужное место.",
            color: 0xfacc15
        },
        "Centrioles": {
            name: "Центриоли",
            desc: "Пара цилиндрических структур, расположенных перпендикулярно друг другу. Участвуют в делении клетки, формируя веретено деления.",
            color: 0xe2e8f0
        },
        "Cytoskeleton": {
            name: "Цитоскелет (Микротрубочки)",
            desc: "Каркас клетки из белковых нитей. Поддерживает форму, обеспечивает транспорт органелл и движение самой клетки.",
            color: 0x38bdf8
        }
    };

    // --- СЦЕНА ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0f172a, 0.02);

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 10, 25);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.SoftShadowMap;
    container.appendChild(renderer.domElement);

    // --- ОСВЕЩЕНИЕ ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    // Основной свет (холодный медицинский)
    const mainLight = new THREE.SpotLight(0xffffff, 2);
    mainLight.position.set(10, 20, 15);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    mainLight.shadow.bias = -0.0001;
    scene.add(mainLight);

    // Контровой свет (теплый для контраста)
    const rimLight = new THREE.DirectionalLight(0x38bdf8, 1.5);
    rimLight.position.set(-10, 0, -10);
    scene.add(rimLight);

    // Заполняющий снизу (отскок)
    const fillLight = new THREE.PointLight(0xc084fc, 0.5);
    fillLight.position.set(0, -10, 0);
    scene.add(fillLight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 50;

    // --- ГЕНЕРАЦИЯ КЛЕТКИ (В РАЗРЕЗЕ) ---
    const cellGroup = new THREE.Group();
    // Наклоним клетку к камере "срезом"
    cellGroup.rotation.x = Math.PI * 0.15;
    scene.add(cellGroup);

    const objects = []; // Для рейкастинга

    // 1. Мембрана (Срезанная сфера)
    // Используем phiLength < 2PI чтобы сделать вырез
    const membraneGeo = new THREE.SphereGeometry(9, 128, 128, 0, Math.PI * 2, 0, Math.PI * 0.65);
    // Материал с подповерхностным рассеиванием (симуляция через MeshPhysicalMaterial)
    const membraneMat = new THREE.MeshPhysicalMaterial({
        color: 0x3b82f6,
        roughness: 0.2,
        metalness: 0.1,
        transmission: 0.1, // Легкая прозрачность
        thickness: 1.0,
        clearcoat: 0.5,
        side: THREE.DoubleSide
    });
    const membrane = new THREE.Mesh(membraneGeo, membraneMat);
    membrane.rotation.x = Math.PI; // Переворачиваем чашей вверх
    membrane.receiveShadow = true;
    membrane.userData = {key: "Membrane"};
    cellGroup.add(membrane);
    objects.push(membrane);

    // 2. Цитозоль (Заполнитель дна)
    const cytoGeo = new THREE.CircleGeometry(8.5, 64);
    const cytoMat = new THREE.MeshStandardMaterial({
        color: 0x1e293b,
        roughness: 0.9,
        metalness: 0.0
    });
    const cytosol = new THREE.Mesh(cytoGeo, cytoMat);
    cytosol.rotation.x = -Math.PI / 2;
    cytosol.position.y = -2; // Чуть ниже края
    cytosol.userData = {key: "Cytoplasm"};
    // cellGroup.add(cytosol); // Можно не добавлять отдельно, если мембрана достаточно плотная

    // 3. Ядро (Сфера с порами)
    const nucleusGroup = new THREE.Group();
    nucleusGroup.position.set(0, -1, 0);
    cellGroup.add(nucleusGroup);

    const nucleusGeo = new THREE.SphereGeometry(2.5, 64, 64);
    // Текстура пор (процедурная)
    const cvs = document.createElement('canvas');
    cvs.width = 512;
    cvs.height = 512;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#a855f7';
    ctx.fillRect(0, 0, 512, 512);
    for (let i = 0; i < 300; i++) {
        ctx.fillStyle = '#7e22ce';
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const r = Math.random() * 3 + 1;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }
    const nucTex = new THREE.CanvasTexture(cvs);

    const nucleusMat = new THREE.MeshStandardMaterial({
        map: nucTex,
        roughness: 0.6,
        bumpMap: nucTex,
        bumpScale: 0.05
    });
    const nucleus = new THREE.Mesh(nucleusGeo, nucleusMat);
    nucleus.userData = {key: "Nucleus"};
    nucleus.castShadow = true;
    nucleusGroup.add(nucleus);
    objects.push(nucleus);

    // 4. Шероховатая ЭПС (Слои вокруг ядра)
    // Генерируем несколько искаженных торусов
    const roughERGeo = new THREE.TorusGeometry(3.5, 0.4, 32, 100);
    // Искажаем вершины для органичности
    const posER = roughERGeo.attributes.position;
    for (let i = 0; i < posER.count; i++) {
        const x = posER.getX(i);
        const y = posER.getY(i);
        const z = posER.getZ(i);
        const noise = Math.sin(x * 2) * 0.2 + Math.cos(y * 3) * 0.2;
        posER.setXYZ(i, x + noise, y + noise, z + Math.sin(z) * 0.3);
    }
    roughERGeo.computeVertexNormals();

    const roughERMat = new THREE.MeshStandardMaterial({
        color: 0xd946ef,
        roughness: 0.5,
        flatShading: false
    });

    // Создаем несколько слоев
    for (let i = 0; i < 3; i++) {
        const layer = new THREE.Mesh(roughERGeo, roughERMat);
        layer.rotation.x = Math.PI / 2;
        layer.rotation.z = Math.random() * Math.PI;
        layer.scale.setScalar(1 + i * 0.2);
        layer.position.y = -1;
        layer.userData = {key: "RoughER"};
        nucleusGroup.add(layer);
        objects.push(layer);
    }

    // 5. Митохондрии (Детализированные)
    const mitoGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
    const mitoMat = new THREE.MeshStandardMaterial({color: 0xf97316, roughness: 0.3});

    // Внутренние кристы (текстура)
    const mitoTexCanvas = document.createElement('canvas');
    mitoTexCanvas.width = 128;
    mitoTexCanvas.height = 128;
    const mCtx = mitoTexCanvas.getContext('2d');
    mCtx.fillStyle = '#f97316';
    mCtx.fillRect(0, 0, 128, 128);
    mCtx.strokeStyle = '#c2410c';
    mCtx.lineWidth = 4;
    for (let i = 0; i < 10; i++) {
        mCtx.beginPath();
        mCtx.moveTo(10, 10 + i * 10);
        mCtx.bezierCurveTo(40, 10 + i * 10 - 10, 80, 10 + i * 10 + 10, 118, 10 + i * 10);
        mCtx.stroke();
    }
    const mitoTex = new THREE.CanvasTexture(mitoTexCanvas);
    mitoMat.map = mitoTex;

    function addMito(x, y, z, rot) {
        const m = new THREE.Mesh(mitoGeo, mitoMat);
        m.position.set(x, y, z);
        m.rotation.set(rot.x, rot.y, rot.z);
        m.castShadow = true;
        m.userData = {key: "Mitochondria"};
        cellGroup.add(m);
        objects.push(m);
    }

    addMito(4, 0, 2, {x: 0.5, y: 0.5, z: 0});
    addMito(-5, 1, -2, {x: 1, y: 0.2, z: 0.5});
    addMito(2, -2, -4, {x: 0, y: 1, z: 0.2});
    addMito(-3, -1, 4, {x: 2, y: 0.5, z: 0});

    // 6. Аппарат Гольджи (Изогнутые пластины)
    const golgiGroup = new THREE.Group();
    golgiGroup.position.set(5, -1, -2);
    golgiGroup.rotation.y = -0.5;
    cellGroup.add(golgiGroup);

    // Используем TubeGeometry по дуге
    class GolgiCurve extends THREE.Curve {
        constructor(scale = 1) {
            super();
            this.scale = scale;
        }

        getPoint(t) {
            const angle = (t - 0.5) * 2; // -1 to 1
            const x = Math.cos(angle) * 2 * this.scale;
            const z = Math.sin(angle) * 1 * this.scale;
            return new THREE.Vector3(x, 0, z);
        }
    }

    const golgiMat = new THREE.MeshStandardMaterial({color: 0xeab308, roughness: 0.4});

    for (let i = 0; i < 5; i++) {
        const curve = new GolgiCurve(1 - i * 0.1);
        const tube = new THREE.TubeGeometry(curve, 20, 0.2, 8, false);
        const mesh = new THREE.Mesh(tube, golgiMat);
        mesh.position.y = i * 0.4;
        mesh.userData = {key: "Golgi"};
        golgiGroup.add(mesh);
        objects.push(mesh); // Каждый слой кликабелен
    }

    // 7. Центриоли (Трубочки)
    const centGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 12);
    const centMat = new THREE.MeshStandardMaterial({color: 0xcbd5e1});

    const c1 = new THREE.Mesh(centGeo, centMat);
    c1.position.set(-2, 1, 3);
    c1.userData = {key: "Centrioles"};

    const c2 = new THREE.Mesh(centGeo, centMat);
    c2.position.set(-2, 1, 3);
    c2.rotation.z = Math.PI / 2;
    c2.userData = {key: "Centrioles"};

    // Объединим их для удобства
    const centGroup = new THREE.Group();
    centGroup.add(c1);
    centGroup.add(c2);
    cellGroup.add(centGroup);
    // Хитбокс для центриолей
    const cHit = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({visible: false}));
    cHit.position.set(-2, 1, 3);
    cHit.userData = {key: "Centrioles"};
    cellGroup.add(cHit);
    objects.push(cHit);

    // 8. Цитоскелет (Нити)
    const microtubules = new THREE.Group();
    const lineMat = new THREE.LineBasicMaterial({color: 0x38bdf8, transparent: true, opacity: 0.3});

    for (let i = 0; i < 20; i++) {
        const p1 = new THREE.Vector3((Math.random() - 0.5) * 12, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 12);
        const p2 = new THREE.Vector3((Math.random() - 0.5) * 12, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 12);
        const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
        const line = new THREE.Line(geo, lineMat);
        microtubules.add(line);
    }
    microtubules.userData = {key: "Cytoskeleton"};
    cellGroup.add(microtubules);
    // Для кликабельности линий нужен Line Raycasting threshold, но лучше просто игнорировать или добавить общий объем

    // --- ЛОГИКА ВЗАИМОДЕЙСТВИЯ ---
    const raycaster = new THREE.Raycaster();
    raycaster.params.Line.threshold = 0.5; // Чтобы легче попадать в линии цитоскелета
    const mouse = new THREE.Vector2();

    const panel = document.getElementById('info-panel');
    const titleEl = document.getElementById('info-title');
    const descEl = document.getElementById('info-desc');
    const hoverLabel = document.getElementById('hover-label');

    let highlightedObj = null;

    function updateRaycaster(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
    }

    // Умный поиск объекта
    function getHitObject(intersects) {
        // Проходим по списку пересечений
        for (let hit of intersects) {
            const obj = hit.object;

            // Пропускаем невидимые хитбоксы при визуальной проверке,
            // но если это первый хит - берем его.

            if (obj.userData.key) {
                // Если мы попали в мембрану, но за ней есть что-то еще близко?
                // В режиме cut-away мы видим внутренности.
                // Мембрана имеет back-face.

                // Логика: Если первый хит - мембрана, проверяем, не "смотрит" ли она внутренней стороной.
                // Но проще: если key == Membrane, проверяем следующий хит.
                // Если следующий хит близко (внутри клетки), выбираем его.

                if (obj.userData.key === "Membrane") {
                    // Если есть второй объект и это не мембрана
                    if (intersects.length > 1 && intersects[1].object.userData.key !== "Membrane") {
                        return intersects[1].object;
                    }
                }
                return obj;
            }
        }
        return null;
    }

    function onMouseMove(event) {
        updateRaycaster(event);
        const intersects = raycaster.intersectObjects(objects); // objects содержит все кликабельные части

        // Также проверяем цитоскелет отдельно, так как он группа линий
        // Но для простоты опустим линии в objects

        const found = getHitObject(intersects);

        if (found) {
            const key = found.userData.key;
            const data = cellData[key];

            hoverLabel.textContent = data.name;
            hoverLabel.style.opacity = 1;

            // Следование за мышью + сдвиг
            hoverLabel.style.left = `${event.clientX}px`;
            hoverLabel.style.top = `${event.clientY}px`;

            document.body.style.cursor = 'pointer';
        } else {
            hoverLabel.style.opacity = 0;
            document.body.style.cursor = 'default';
        }
    }

    function onClick(event) {
        if (event.target.closest('#info-panel') || event.target.closest('.close-btn')) return;

        updateRaycaster(event);
        const intersects = raycaster.intersectObjects(objects);
        const found = getHitObject(intersects);

        if (found) {
            showInfo(found.userData.key);

            // Подсветка
            if (highlightedObj) {
                // Возвращаем как было
                if (highlightedObj.material.emissive) highlightedObj.material.emissive.setHex(0x000000);
            }

            highlightedObj = found;
            if (found.material && found.material.emissive) {
                // Цвет эмиссии зависит от цвета объекта
                found.material.emissive.setHex(0x333333);
            }
        } else {
            closePanel();
        }
    }

    function showInfo(key) {
        const data = cellData[key];
        titleEl.textContent = data.name;
        descEl.textContent = data.desc;

        const hexColor = '#' + new THREE.Color(data.color).getHexString();
        panel.style.borderLeftColor = hexColor;
        titleEl.style.color = hexColor;

        panel.classList.add('active');
    }

    window.closePanel = function () {
        panel.classList.remove('active');
        if (highlightedObj && highlightedObj.material.emissive) {
            highlightedObj.material.emissive.setHex(0x000000);
        }
        highlightedObj = null;
    };

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onClick);

    // --- АНИМАЦИЯ ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        const time = Date.now() * 0.001;

        // Мягкое покачивание всей клетки
        cellGroup.rotation.y = Math.sin(time * 0.05) * 0.1 + Math.PI * 0.15; // + базовый поворот
        cellGroup.rotation.z = Math.cos(time * 0.03) * 0.05;

        // Пульсация ядра
        nucleus.scale.setScalar(1 + Math.sin(time) * 0.01);

        // Движение митохондрий (плавание)
        objects.forEach(obj => {
            if (obj.userData.key === "Mitochondria") {
                obj.position.y += Math.sin(time + obj.id) * 0.002;
            }
        });

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    document.getElementById('loading').style.display = 'none';
    animate();

</script>
</body>
</html>