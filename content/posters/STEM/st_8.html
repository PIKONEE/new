<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ç—ã–∫–æ–≤–∫–∞ —Å –ú–ö–° - –°–∏–º—É–ª—è—Ç–æ—Ä | STEM 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #0a0e1a 0%, #000000 100%);
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
            position: relative;
        }

        /* –ó–≤–µ–∑–¥–Ω–æ–µ –ø–æ–ª–µ */
        #stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 25px 35px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
            z-index: 100;
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 15px rgba(0, 200, 255, 0.6);
            letter-spacing: 1px;
        }

        .title span {
            color: #00c8ff;
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 5px;
            font-weight: 300;
        }

        /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .control-panel {
            position: fixed;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(10, 15, 30, 0.95);
            backdrop-filter: blur(25px);
            border-radius: 20px;
            padding: 28px;
            width: 340px;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6), 0 0 40px rgba(0, 200, 255, 0.15);
            z-index: 100;
        }

        .panel-title {
            font-size: 17px;
            font-weight: 600;
            margin-bottom: 22px;
            color: #00c8ff;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 14px;
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.75);
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
        }

        .control-value {
            color: #00c8ff;
            font-weight: 700;
            font-size: 15px;
            background: rgba(0, 200, 255, 0.12);
            padding: 4px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00c8ff, #0080ff);
            cursor: pointer;
            box-shadow: 0 2px 12px rgba(0, 200, 255, 0.6);
            transition: transform 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .btn {
            width: 100%;
            padding: 15px 22px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn.primary {
            background: linear-gradient(135deg, #00c8ff, #0080ff);
            color: #000;
            box-shadow: 0 4px 20px rgba(0, 200, 255, 0.3);
        }

        .btn.primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 35px rgba(0, 200, 255, 0.5);
        }

        .btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .btn.secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn.secondary.active {
            background: rgba(0, 200, 255, 0.25);
            border-color: #00c8ff;
            box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }

        .btn.danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 35px rgba(255, 68, 68, 0.5);
        }

        /* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å */
        .info-panel {
            position: fixed;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(10, 15, 30, 0.95);
            backdrop-filter: blur(25px);
            border-radius: 20px;
            padding: 28px;
            width: 360px;
            border: 1px solid rgba(255, 200, 0, 0.3);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6), 0 0 40px rgba(255, 200, 0, 0.15);
            z-index: 100;
        }

        .info-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 22px;
            color: #ffc800;
            display: flex;
            align-items: center;
            gap: 12px;
            padding-bottom: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .metric-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .metric-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #00c8ff;
            font-family: 'Courier New', monospace;
        }

        .metric-unit {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-left: 4px;
        }

        .status-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 18px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .status-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .status-value {
            font-size: 16px;
            font-weight: 600;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .status-value.standby {
            background: rgba(100, 100, 100, 0.3);
            color: #aaa;
        }

        .status-value.approaching {
            background: rgba(255, 200, 0, 0.2);
            color: #ffc800;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-value.aligned {
            background: rgba(0, 200, 255, 0.2);
            color: #00c8ff;
        }

        .status-value.docked {
            background: rgba(0, 255, 100, 0.2);
            color: #00ff64;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-value.failed {
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
            animation: shake 0.5s;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-5px);
            }
            75% {
                transform: translateX(5px);
            }
        }

        .alignment-indicator {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .alignment-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .alignment-bars {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .alignment-bar {
            background: rgba(255, 255, 255, 0.1);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .alignment-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .alignment-fill.x {
            background: linear-gradient(90deg, #ff4444, #00ff64);
        }

        .alignment-fill.y {
            background: linear-gradient(90deg, #4444ff, #00ff64);
        }

        .alignment-fill.z {
            background: linear-gradient(90deg, #ff44ff, #00ff64);
        }

        /* HUD —ç–ª–µ–º–µ–Ω—Ç—ã */
        .hud-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 200, 255, 0.6);
            border-radius: 50%;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 200, 255, 0.6);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* –¢–µ–æ—Ä–∏—è */
        .theory-panel {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 30, 0.95);
            backdrop-filter: blur(25px);
            border-radius: 20px;
            padding: 25px 30px;
            max-width: 700px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6);
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .theory-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .theory-title {
            font-size: 16px;
            font-weight: 700;
            color: #00c8ff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .theory-content {
            font-size: 13px;
            line-height: 1.7;
            color: rgba(255, 255, 255, 0.85);
        }

        .theory-content strong {
            color: #ffc800;
        }

        /* –ó–≤–µ–∑–¥—ã –Ω–∞ —Ñ–æ–Ω–µ */
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% {
                opacity: 0.3;
            }
            50% {
                opacity: 1;
            }
        }

        /* –ü–ª–∞–Ω–µ—Ç–∞ –ó–µ–º–ª—è */
        .earth {
            position: fixed;
            bottom: -30%;
            left: -10%;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle at 30% 30%, #4a90e2, #1e3a8a);
            border-radius: 50%;
            box-shadow: 0 0 100px rgba(74, 144, 226, 0.5),
            inset -30px -30px 80px rgba(0, 0, 0, 0.5);
            z-index: 0;
            opacity: 0.4;
        }
    </style>
</head>
<body>
<!-- –ó–≤–µ–∑–¥—ã -->
<div id="stars"></div>
<div class="earth"></div>

<!-- HUD -->
<div class="hud-overlay">
    <div class="crosshair"></div>
</div>

<!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
<div class="header">
    <div class="title">–°—Ç—ã–∫–æ–≤–∫–∞ —Å <span>–ú–ö–°</span></div>
    <div class="subtitle">–°–∏–º—É–ª—è—Ç–æ—Ä —Å–±–ª–∏–∂–µ–Ω–∏—è –∏ —Å—Ç—ã–∫–æ–≤–∫–∏ –∫–æ—Å–º–∏—á–µ—Å–∫–æ–≥–æ –∫–æ—Ä–∞–±–ª—è</div>
</div>

<!-- 3D Canvas -->
<div id="canvas-container"></div>

<!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
<div class="control-panel">
    <div class="panel-title">‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>

    <button class="btn primary" id="start-btn" onclick="startDocking()">üöÄ –ù–∞—á–∞—Ç—å —Å—Ç—ã–∫–æ–≤–∫—É</button>
    <button class="btn danger" id="reset-btn" onclick="resetSimulation()">üîÑ –°–±—Ä–æ—Å</button>

    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
        <div class="control-label" style="margin-bottom: 12px;">
            <span>üéõÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—ã–∫–æ–≤–∫–∏</span>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span style="font-size: 11px;">–°–∫–æ—Ä–æ—Å—Ç—å —Å–±–ª–∏–∂–µ–Ω–∏—è</span>
                <span class="control-value" id="speed-val" style="font-size: 12px;">100%</span>
            </div>
            <input type="range" id="speed-slider" min="50" max="200" value="100" step="10" oninput="updateSpeed()">
        </div>

        <button class="btn secondary" id="pause-btn" onclick="togglePause()" style="margin-bottom: 8px;">‚è∏Ô∏è –ü–∞—É–∑–∞
        </button>
        <button class="btn secondary" id="skip-btn" onclick="skipPhase()">‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ñ–∞–∑—É</button>
    </div>

    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
        <button class="btn secondary" id="theory-btn" onclick="toggleTheory()">üìö –¢–µ–æ—Ä–∏—è</button>

        <div class="control-label" style="margin-top: 15px; margin-bottom: 8px;">
            <span style="font-size: 10px;">üí° –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π</span>
        </div>
        <div style="font-size: 10px; color: rgba(255,255,255,0.5); line-height: 1.5;">
            ‚Ä¢ –õ–ö–ú + –¥–≤–∏–∂–µ–Ω–∏–µ –º—ã—à–∏ - –≤—Ä–∞—â–µ–Ω–∏–µ<br>
            ‚Ä¢ –ö–æ–ª–µ—Å–∏–∫–æ - –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ/–æ—Ç–¥–∞–ª–µ–Ω–∏–µ
        </div>
    </div>
</div>

<!-- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å -->
<div class="info-panel">
    <div class="info-title">üìä –¢–µ–ª–µ–º–µ—Ç—Ä–∏—è</div>

    <div class="metric-grid">
        <div class="metric">
            <div class="metric-label">–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ</div>
            <div class="metric-value" id="distance">150<span class="metric-unit">–º</span></div>
        </div>
        <div class="metric">
            <div class="metric-label">–°–∫–æ—Ä–æ—Å—Ç—å</div>
            <div class="metric-value" id="velocity">0.0<span class="metric-unit">–º/—Å</span></div>
        </div>
        <div class="metric">
            <div class="metric-label">–£–≥–æ–ª</div>
            <div class="metric-value" id="angle">0<span class="metric-unit">¬∞</span></div>
        </div>
        <div class="metric">
            <div class="metric-label">–¢–æ–ø–ª–∏–≤–æ</div>
            <div class="metric-value" id="fuel">100<span class="metric-unit">%</span></div>
        </div>
    </div>

    <div class="status-section">
        <div class="status-label">–°—Ç–∞—Ç—É—Å –º–∏—Å—Å–∏–∏</div>
        <div class="status-value standby" id="status">–û–ñ–ò–î–ê–ù–ò–ï</div>
    </div>

    <div class="alignment-indicator">
        <div class="alignment-label">–í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –æ—Å–µ–π</div>
        <div class="alignment-bars">
            <div class="alignment-bar">
                <div class="alignment-fill x" id="align-x" style="width: 50%"></div>
            </div>
            <div class="alignment-bar">
                <div class="alignment-fill y" id="align-y" style="width: 50%"></div>
            </div>
            <div class="alignment-bar">
                <div class="alignment-fill z" id="align-z" style="width: 50%"></div>
            </div>
        </div>
    </div>
</div>

<!-- –¢–µ–æ—Ä–∏—è -->
<div class="theory-panel" id="theory-panel">
    <div class="theory-title">üöÄ –ö–∞–∫ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å—Ç—ã–∫–æ–≤–∫–∞</div>
    <div class="theory-content">
        <strong>–≠—Ç–∞–ø—ã —Å—Ç—ã–∫–æ–≤–∫–∏:</strong><br>
        1. <strong>–°–±–ª–∏–∂–µ–Ω–∏–µ</strong> - –∫–æ—Ä–∞–±–ª—å –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç—Å—è –∫ —Å—Ç–∞–Ω—Ü–∏–∏ —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—å—é ~1 –º/—Å<br>
        2. <strong>–í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ</strong> - —Ç–æ—á–Ω–æ–µ —Å–æ–≤–º–µ—â–µ–Ω–∏–µ –æ—Å–µ–π —Å—Ç—ã–∫–æ–≤–æ—á–Ω—ã—Ö –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤<br>
        3. <strong>–ó–∞—Ö–≤–∞—Ç</strong> - –∞–∫—Ç–∏–≤–∞—Ü–∏—è —Å—Ç—ã–∫–æ–≤–æ—á–Ω–æ–≥–æ –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø—Ä–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ <5 –º<br>
        4. <strong>–ì–µ—Ä–º–µ—Ç–∏–∑–∞—Ü–∏—è</strong> - —Å–æ–∑–¥–∞–Ω–∏–µ –≥–µ—Ä–º–µ—Ç–∏—á–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è<br><br>
        <strong>–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:</strong> —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ <2–º, —Å–∫–æ—Ä–æ—Å—Ç—å —Å–±–ª–∏–∂–µ–Ω–∏—è <0.3 –º/—Å, —É–≥–æ–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è <5¬∞
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã Three.js
    let scene, camera, renderer, controls;
    let spacecraft, iss, stars;
    let dockingInProgress = false;
    let dockingPhase = 0; // 0-–Ω–µ –Ω–∞—á–∞–ª–∞—Å—å, 1-—Å–±–ª–∏–∂–µ–Ω–∏–µ, 2-—Ç–æ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è, 3-–∑–∞—Ö–≤–∞—Ç, 4-–∑–∞–≤–µ—Ä—à–µ–Ω–æ

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏–º—É–ª—è—Ü–∏–∏
    let state = {
        position: {x: 0, y: 0, z: -100},
        velocity: {x: 0, y: 0, z: 0},
        rotation: 0,
        rotationVel: 0,
        fuel: 100,
        status: 'standby'
    };

    function init() {
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 150, 600);

        // –ö–∞–º–µ—Ä–∞ - –≤–∏–¥ —Å–±–æ–∫—É
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(80, 30, 80);
        camera.lookAt(0, 0, 0);

        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // –î–æ–±–∞–≤–ª—è–µ–º OrbitControls –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
        addOrbitControls();

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(150, 100, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
        fillLight.position.set(-50, 0, -50);
        scene.add(fillLight);

        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–≤–µ–∑–¥
        createStarField();
        createBackgroundStars();

        // –°–æ–∑–¥–∞–Ω–∏–µ –ú–ö–°
        createISS();

        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Å–º–∏—á–µ—Å–∫–æ–≥–æ –∫–æ—Ä–∞–±–ª—è
        createSpacecraft();

        // –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
        animate();
    }

    // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è OrbitControls
    function addOrbitControls() {
        let isDragging = false;
        let previousMousePosition = {x: 0, y: 0};
        let cameraDistance = Math.sqrt(
                camera.position.x ** 2 +
                camera.position.y ** 2 +
                camera.position.z ** 2
        );
        let theta = Math.atan2(camera.position.x, camera.position.z);
        let phi = Math.acos(camera.position.y / cameraDistance);

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = {x: e.clientX, y: e.clientY};
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                theta -= deltaX * 0.005;
                phi -= deltaY * 0.005;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                camera.position.x = cameraDistance * Math.sin(phi) * Math.sin(theta);
                camera.position.y = cameraDistance * Math.cos(phi);
                camera.position.z = cameraDistance * Math.sin(phi) * Math.cos(theta);

                camera.lookAt(0, 0, 0);
                previousMousePosition = {x: e.clientX, y: e.clientY};
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.05;
            cameraDistance = Math.max(30, Math.min(200, cameraDistance));

            camera.position.x = cameraDistance * Math.sin(phi) * Math.sin(theta);
            camera.position.y = cameraDistance * Math.cos(phi);
            camera.position.z = cameraDistance * Math.sin(phi) * Math.cos(theta);

            camera.lookAt(0, 0, 0);
        });
    }

    function createStarField() {
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8
        });

        const starsVertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function createBackgroundStars() {
        const container = document.getElementById('stars');
        for (let i = 0; i < 100; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            const size = Math.random() * 2 + 1;
            star.style.width = size + 'px';
            star.style.height = size + 'px';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.animationDelay = Math.random() * 3 + 's';
            container.appendChild(star);
        }
    }

    function createISS() {
        iss = new THREE.Group();

        // === –¶–ï–ù–¢–†–ê–õ–¨–ù–ê–Ø –§–ï–†–ú–ê (TRUSS) ===
        const trussSegments = [];
        const trussLength = 50;
        const segmentCount = 10;

        for (let i = 0; i < segmentCount; i++) {
            const x = (i - segmentCount / 2) * (trussLength / segmentCount);

            // –û—Å–Ω–æ–≤–Ω–∞—è –±–∞–ª–∫–∞
            const beam = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.8, 0.8, 8, 2, 2),
                    new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        metalness: 0.8,
                        roughness: 0.3
                    })
            );
            beam.position.x = x;
            beam.castShadow = true;
            iss.add(beam);

            // –ü–æ–ø–µ—Ä–µ—á–Ω—ã–µ –±–∞–ª–∫–∏
            const crossBeam1 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 3, 0.5, 2, 6, 2),
                    new THREE.MeshStandardMaterial({
                        color: 0x777777,
                        metalness: 0.8,
                        roughness: 0.3
                    })
            );
            crossBeam1.position.set(x, 0, 0);
            iss.add(crossBeam1);

            // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∏
            if (i % 2 === 0) {
                const diag1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 4, 8),
                        new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.9})
                );
                diag1.position.set(x, 0.5, 0);
                diag1.rotation.z = Math.PI / 4;
                iss.add(diag1);

                const diag2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 4, 8),
                        new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.9})
                );
                diag2.position.set(x, -0.5, 0);
                diag2.rotation.z = -Math.PI / 4;
                iss.add(diag2);
            }
        }

        // === –ú–û–î–£–õ–ò –°–¢–ê–ù–¶–ò–ò ===

        // Zarya (–ó–∞—Ä—è) - –ø–µ—Ä–≤—ã–π –º–æ–¥—É–ª—å
        const zarya = new THREE.Group();
        const zaryaBody = new THREE.Mesh(
                new THREE.CylinderGeometry(2.3, 2.3, 13, 32, 4),
                new THREE.MeshStandardMaterial({
                    color: 0xdddddd,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        zaryaBody.rotation.z = Math.PI / 2;
        zaryaBody.castShadow = true;
        zarya.add(zaryaBody);

        // –î–µ—Ç–∞–ª–∏ –º–æ–¥—É–ª—è –ó–∞—Ä—è
        for (let i = 0; i < 6; i++) {
            const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(2.35, 0.08, 8, 24),
                    new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.8})
            );
            ring.rotation.y = Math.PI / 2;
            ring.position.x = -6 + i * 2.4;
            zarya.add(ring);
        }

        // –†–∞–¥–∏–∞—Ç–æ—Ä—ã
        for (let side of [-1, 1]) {
            const radiator = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 3, 0.1, 16, 6, 1),
                    new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.5
                    })
            );
            radiator.position.set(0, side * 3, 0);
            zarya.add(radiator);

            // –†–µ—à–µ—Ç–∫–∞ —Ä–∞–¥–∏–∞—Ç–æ—Ä–∞
            const gridGeometry = new THREE.BufferGeometry();
            const gridPoints = [];
            for (let i = -4; i <= 4; i += 0.5) {
                gridPoints.push(i, -1.5, 0.06, i, 1.5, 0.06);
            }
            for (let j = -1.5; j <= 1.5; j += 0.5) {
                gridPoints.push(-4, j, 0.06, 4, j, 0.06);
            }
            gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
            const grid = new THREE.LineSegments(gridGeometry, new THREE.LineBasicMaterial({color: 0x555555}));
            grid.position.set(0, side * 3, 0);
            zarya.add(grid);
        }

        zarya.position.set(0, 0, 0);
        iss.add(zarya);

        // Zvezda (–ó–≤–µ–∑–¥–∞) - –∂–∏–ª–æ–π –º–æ–¥—É–ª—å
        const zvezda = new THREE.Group();
        const zvezdaBody = new THREE.Mesh(
                new THREE.CylinderGeometry(2.2, 2.2, 13, 32, 4),
                new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        zvezdaBody.rotation.z = Math.PI / 2;
        zvezdaBody.castShadow = true;
        zvezda.add(zvezdaBody);

        // –û–∫–Ω–∞ –º–æ–¥—É–ª—è –ó–≤–µ–∑–¥–∞
        for (let i = 0; i < 4; i++) {
            const window = new THREE.Mesh(
                    new THREE.CircleGeometry(0.3, 16),
                    new THREE.MeshStandardMaterial({
                        color: 0x111111,
                        emissive: 0x4a90e2,
                        emissiveIntensity: 0.3
                    })
            );
            const angle = (Math.PI / 2) * i;
            window.position.set(3, Math.cos(angle) * 2.25, Math.sin(angle) * 2.25);
            window.rotation.y = Math.PI / 2;
            window.rotation.z = -angle;
            zvezda.add(window);
        }

        zvezda.position.set(-15, 0, 0);
        iss.add(zvezda);

        // Unity (Node 1) - —Å–æ–µ–¥–∏–Ω–∏—Ç–µ–ª—å–Ω—ã–π —É–∑–µ–ª
        const unity = new THREE.Mesh(
                new THREE.CylinderGeometry(2.5, 2.5, 5, 16, 2),
                new THREE.MeshStandardMaterial({
                    color: 0xbbbbbb,
                    metalness: 0.7,
                    roughness: 0.3
                })
        );
        unity.castShadow = true;
        unity.position.set(10, 0, 0);
        iss.add(unity);

        // Destiny (–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–π –º–æ–¥—É–ª—å –°–®–ê)
        const destiny = new THREE.Group();
        const destinyBody = new THREE.Mesh(
                new THREE.CylinderGeometry(2.1, 2.1, 8.5, 24, 3),
                new THREE.MeshStandardMaterial({
                    color: 0xdedede,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        destinyBody.rotation.z = Math.PI / 2;
        destinyBody.castShadow = true;
        destiny.add(destinyBody);

        destiny.position.set(17, 0, 0);
        iss.add(destiny);

        // Columbus (–µ–≤—Ä–æ–ø–µ–π—Å–∫–∏–π –º–æ–¥—É–ª—å)
        const columbus = new THREE.Mesh(
                new THREE.CylinderGeometry(2.2, 2.2, 7, 24, 3),
                new THREE.MeshStandardMaterial({
                    color: 0xd0d0d0,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        columbus.rotation.x = Math.PI / 2;
        columbus.castShadow = true;
        columbus.position.set(10, 0, 5);
        iss.add(columbus);

        // Kibo (—è–ø–æ–Ω—Å–∫–∏–π –º–æ–¥—É–ª—å)
        const kibo = new THREE.Mesh(
                new THREE.CylinderGeometry(2.2, 2.2, 11, 24, 3),
                new THREE.MeshStandardMaterial({
                    color: 0xe0e0e0,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        kibo.rotation.x = Math.PI / 2;
        kibo.castShadow = true;
        kibo.position.set(10, 0, -7);
        iss.add(kibo);

        // === –°–¢–´–ö–û–í–û–ß–ù–´–ô –ú–û–î–£–õ–¨ ===
        const dockingModule = new THREE.Group();

        const dockingBody = new THREE.Mesh(
                new THREE.CylinderGeometry(1.8, 1.8, 4, 24),
                new THREE.MeshStandardMaterial({
                    color: 0xaaaaaa,
                    metalness: 0.7,
                    roughness: 0.3
                })
        );
        dockingBody.castShadow = true;
        dockingModule.add(dockingBody);

        // –°—Ç—ã–∫–æ–≤–æ—á–Ω—ã–π –∫–æ–Ω—É—Å
        const dockingCone = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.8, 2, 24),
                new THREE.MeshStandardMaterial({
                    color: 0x999999,
                    metalness: 0.8,
                    roughness: 0.2
                })
        );
        dockingCone.position.y = 3;
        dockingModule.add(dockingCone);

        // –°—Ç—ã–∫–æ–≤–æ—á–Ω–æ–µ –∫–æ–ª—å—Ü–æ
        const dockingRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.2, 0.15, 16, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xffaa00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.6,
                    metalness: 0.9,
                    roughness: 0.1
                })
        );
        dockingRing.position.y = 4;
        dockingRing.rotation.x = Math.PI / 2;
        dockingModule.add(dockingRing);

        // –û–≥–Ω–∏ —Å—Ç—ã–∫–æ–≤–æ—á–Ω–æ–≥–æ –ø–æ—Ä—Ç–∞
        const dockingLights = [0, Math.PI / 2, Math.PI, Math.PI * 1.5];
        dockingLights.forEach((angle, i) => {
            const light = new THREE.PointLight(0x00c8ff, 1.5, 20);
            light.position.set(
                    Math.cos(angle) * 1.5,
                    4.2,
                    Math.sin(angle) * 1.5
            );
            dockingModule.add(light);

            const lightMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 12, 12),
                    new THREE.MeshBasicMaterial({
                        color: 0x00c8ff,
                        emissive: 0x00c8ff,
                        emissiveIntensity: 1
                    })
            );
            lightMesh.position.copy(light.position);
            dockingModule.add(lightMesh);
        });

        dockingModule.position.set(24, 0, 0);
        iss.add(dockingModule);

        // === –°–û–õ–ù–ï–ß–ù–´–ï –ü–ê–ù–ï–õ–ò ===
        iss.solarPanels = [];

        const createSolarArray = (x, y, z) => {
            const solarGroup = new THREE.Group();

            // –§–µ—Ä–º–∞ –¥–ª—è –ø–∞–Ω–µ–ª–µ–π
            const mast = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.4, 12, 2, 2, 24),
                    new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        metalness: 0.8,
                        roughness: 0.4
                    })
            );
            solarGroup.add(mast);

            // –ú–µ—Ö–∞–Ω–∏–∑–º –≤—Ä–∞—â–µ–Ω–∏—è
            const rotator = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 1, 16),
                    new THREE.MeshStandardMaterial({
                        color: 0x555555,
                        metalness: 0.9,
                        roughness: 0.2
                    })
            );
            rotator.rotation.x = Math.PI / 2;
            rotator.position.z = 6;
            solarGroup.add(rotator);

            // –°–æ–ª–Ω–µ—á–Ω–∞—è –ø–∞–Ω–µ–ª—å (–¥–≤–æ–π–Ω–∞—è)
            const panelGroup = new THREE.Group();

            for (let side of [-1, 1]) {
                const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(18, 6, 0.15, 36, 12, 1),
                        new THREE.MeshStandardMaterial({
                            color: 0x1a237e,
                            metalness: 0.95,
                            roughness: 0.05,
                            emissive: 0x0d47a1,
                            emissiveIntensity: 0.15
                        })
                );
                panel.position.x = side * 9.1;
                panelGroup.add(panel);

                // –°–µ—Ç–∫–∞ —è—á–µ–µ–∫ —Å–æ–ª–Ω–µ—á–Ω—ã—Ö –±–∞—Ç–∞—Ä–µ–π
                const gridGeometry = new THREE.BufferGeometry();
                const gridPoints = [];

                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let i = -3; i <= 3; i += 0.5) {
                    gridPoints.push(-9, i, 0.08, 9, i, 0.08);
                }
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                for (let j = -9; j <= 9; j += 0.5) {
                    gridPoints.push(j, -3, 0.08, j, 3, 0.08);
                }

                gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
                const grid = new THREE.LineSegments(
                        gridGeometry,
                        new THREE.LineBasicMaterial({color: 0x000033, linewidth: 1})
                );
                grid.position.x = side * 9.1;
                panelGroup.add(grid);

                // –†–∞–º–∫–∞ –ø–∞–Ω–µ–ª–∏
                const frameGeometry = new THREE.BoxGeometry(18.2, 6.2, 0.2);
                const frameEdges = new THREE.EdgesGeometry(frameGeometry);
                const frameLine = new THREE.LineSegments(
                        frameEdges,
                        new THREE.LineBasicMaterial({color: 0x333333, linewidth: 2})
                );
                frameLine.position.x = side * 9.1;
                panelGroup.add(frameLine);
            }

            panelGroup.position.z = 6;
            solarGroup.add(panelGroup);

            solarGroup.position.set(x, y, z);
            iss.add(solarGroup);

            return panelGroup;
        };

        // 4 –º–∞—Å—Å–∏–≤–∞ —Å–æ–ª–Ω–µ—á–Ω—ã—Ö –ø–∞–Ω–µ–ª–µ–π
        iss.solarPanels.push(createSolarArray(-12, 5, 0));
        iss.solarPanels.push(createSolarArray(-12, -5, 0));
        iss.solarPanels.push(createSolarArray(12, 5, 0));
        iss.solarPanels.push(createSolarArray(12, -5, 0));

        // === –ê–ù–¢–ï–ù–ù–´ –ò –û–ë–û–†–£–î–û–í–ê–ù–ò–ï ===

        // –ì–ª–∞–≤–Ω–∞—è –∞–Ω—Ç–µ–Ω–Ω–∞
        const mainAntenna = new THREE.Group();
        const antennaDish = new THREE.Mesh(
                new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xeeeeee,
                    metalness: 0.9,
                    roughness: 0.1
                })
        );
        antennaDish.rotation.x = Math.PI / 2;
        mainAntenna.add(antennaDish);

        const antennaArm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                new THREE.MeshStandardMaterial({color: 0x666666})
        );
        antennaArm.position.y = 1.5;
        mainAntenna.add(antennaArm);

        mainAntenna.position.set(5, 4, 0);
        iss.add(mainAntenna);

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞–Ω—Ç–µ–Ω–Ω—ã
        for (let i = 0; i < 3; i++) {
            const smallAntenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                    new THREE.MeshStandardMaterial({color: 0x555555})
            );
            smallAntenna.position.set(-8 + i * 8, 3.5, i % 2 === 0 ? 2 : -2);
            smallAntenna.rotation.z = Math.PI / 6;
            iss.add(smallAntenna);
        }

        iss.position.set(0, 0, 0);
        scene.add(iss);
    }

    function createSpacecraft() {
        spacecraft = new THREE.Group();

        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å –∫–∞–ø—Å—É–ª—ã
        const capsule = new THREE.Mesh(
                new THREE.SphereGeometry(2, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshStandardMaterial({
                    color: 0xe0e0e0,
                    metalness: 0.6,
                    roughness: 0.4
                })
        );
        capsule.castShadow = true;
        capsule.receiveShadow = true;
        spacecraft.add(capsule);

        // –¶–∏–ª–∏–Ω–¥—Ä–∏—á–µ—Å–∫–∏–π –∫–æ—Ä–ø—É—Å
        const body = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2, 4, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.7,
                    roughness: 0.3
                })
        );
        body.position.y = -2;
        body.castShadow = true;
        spacecraft.add(body);

        // –°–ª—É–∂–µ–±–Ω—ã–π –º–æ–¥—É–ª—å
        const serviceModule = new THREE.Mesh(
                new THREE.CylinderGeometry(1.8, 2.2, 3, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xcccccc,
                    metalness: 0.8,
                    roughness: 0.2
                })
        );
        serviceModule.position.y = -5.5;
        serviceModule.castShadow = true;
        spacecraft.add(serviceModule);

        // –î–≤–∏–≥–∞—Ç–µ–ª–∏
        const engines = [
            {x: 1.5, z: 1.5},
            {x: -1.5, z: 1.5},
            {x: 1.5, z: -1.5},
            {x: -1.5, z: -1.5}
        ];

        engines.forEach(e => {
            const engine = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 1, 16),
                    new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.9,
                        roughness: 0.1
                    })
            );
            engine.position.set(e.x, -7.5, e.z);
            spacecraft.add(engine);

            // –°–≤–µ—á–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª—è
            const glow = new THREE.PointLight(0xff6600, 0, 5);
            glow.position.set(e.x, -8, e.z);
            spacecraft.add(glow);
        });

        // –°—Ç—ã–∫–æ–≤–æ—á–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º
        const dockingMech = new THREE.Group();

        const mechBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1, 1.5, 16),
                new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    metalness: 0.8
                })
        );
        dockingMech.add(mechBase);

        const mechProbe = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 1, 16),
                new THREE.MeshStandardMaterial({
                    color: 0x555555,
                    metalness: 0.9
                })
        );
        mechProbe.position.y = 1.25;
        dockingMech.add(mechProbe);

        dockingMech.position.y = 2;
        dockingMech.rotation.x = Math.PI;
        spacecraft.add(dockingMech);

        // –ê–Ω—Ç–µ–Ω–Ω—ã
        for (let i = 0; i < 4; i++) {
            const angle = (Math.PI * 2 * i) / 4;
            const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 3, 8),
                    new THREE.MeshStandardMaterial({color: 0x444444})
            );
            antenna.position.set(
                    Math.cos(angle) * 1.5,
                    -3,
                    Math.sin(angle) * 1.5
            );
            antenna.rotation.z = Math.PI / 6;
            spacecraft.add(antenna);
        }

        // –û–≥–Ω–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        const navLights = [
            {color: 0x00ff00, pos: [0, 0, 2]},
            {color: 0xff0000, pos: [0, 0, -2]},
            {color: 0xffffff, pos: [2, 0, 0]},
            {color: 0xffffff, pos: [-2, 0, 0]}
        ];

        navLights.forEach(l => {
            const light = new THREE.PointLight(l.color, 0.5, 10);
            light.position.set(...l.pos);
            spacecraft.add(light);

            const lightMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({
                        color: l.color,
                        emissive: l.color,
                        emissiveIntensity: 1
                    })
            );
            lightMesh.position.set(...l.pos);
            spacecraft.add(lightMesh);
        });

        spacecraft.position.set(0, 0, -150);
        scene.add(spacecraft);
    }

    let dockingSpeed = 1.0;
    let isPaused = false;

    function updateSpeed() {
        const value = document.getElementById('speed-slider').value;
        dockingSpeed = value / 100;
        document.getElementById('speed-val').textContent = value + '%';
    }

    function togglePause() {
        isPaused = !isPaused;
        const btn = document.getElementById('pause-btn');
        if (isPaused) {
            btn.textContent = '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å';
            btn.classList.add('active');
        } else {
            btn.textContent = '‚è∏Ô∏è –ü–∞—É–∑–∞';
            btn.classList.remove('active');
        }
    }

    function skipPhase() {
        if (!dockingInProgress || dockingPhase >= 4) return;

        dockingPhase++;

        // –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –Ω–∞—á–∞–ª—É —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∞–∑—ã
        if (dockingPhase === 2) {
            state.position.z = -30;
            state.velocity = {x: 0, y: 0, z: 0};
        } else if (dockingPhase === 3) {
            state.position.z = -10;
            state.position.x = 0;
            state.position.y = 0;
            state.velocity = {x: 0, y: 0, z: 0};
        } else if (dockingPhase === 4) {
            state.position.z = 0;
            state.position.x = 0;
            state.position.y = 0;
            state.velocity = {x: 0, y: 0, z: 0};
            state.rotation = 0;
        }
    }

    function startDocking() {
        if (dockingInProgress) return;

        dockingInProgress = true;
        dockingPhase = 1;
        state.status = 'approaching';

        document.getElementById('start-btn').disabled = true;
        document.getElementById('start-btn').textContent = '‚è≥ –°—Ç—ã–∫–æ–≤–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ...';

        const statusEl = document.getElementById('status');
        statusEl.textContent = '–ù–ê–ß–ê–õ–û –°–ë–õ–ò–ñ–ï–ù–ò–Ø';
        statusEl.className = 'status-value approaching';
    }

    function updateDocking(delta) {
        if (!dockingInProgress || isPaused) return;

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏
        delta *= dockingSpeed;

        const distance = Math.sqrt(
                state.position.x ** 2 +
                state.position.y ** 2 +
                state.position.z ** 2
        );

        const statusEl = document.getElementById('status');

        // –§–∞–∑–∞ 1: –°–±–ª–∏–∂–µ–Ω–∏–µ —Å –ú–ö–° (100–º -> 30–º)
        if (dockingPhase === 1) {
            statusEl.textContent = '–§–ê–ó–ê 1: –°–ë–õ–ò–ñ–ï–ù–ò–ï';
            statusEl.className = 'status-value approaching';

            // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä–µ–¥ —Å–æ —Å–∫–æ—Ä–æ—Å—Ç—å—é ~0.8 –º/—Å
            const targetZ = -30;
            const speed = 0.5;

            if (state.position.z < targetZ) {
                state.velocity.z = speed;
            } else {
                state.velocity.z = 0;
                dockingPhase = 2;
            }

            // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ–ª–æ–∂–µ–Ω–∏—è –ø–æ X –∏ Y
            state.velocity.x = -state.position.x * 0.02;
            state.velocity.y = -state.position.y * 0.02;
        }

        // –§–∞–∑–∞ 2: –¢–æ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è (30–º -> 10–º)
        else if (dockingPhase === 2) {
            statusEl.textContent = '–§–ê–ó–ê 2: –¢–û–ß–ù–ê–Ø –ö–û–†–†–ï–ö–¶–ò–Ø';
            statusEl.className = 'status-value aligned';

            const targetZ = -10;
            const speed = 0.2;

            if (state.position.z < targetZ) {
                state.velocity.z = speed;
            } else {
                state.velocity.z = 0;
                dockingPhase = 3;
            }

            // –ë–æ–ª–µ–µ —Ç–æ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è
            state.velocity.x = -state.position.x * 0.05;
            state.velocity.y = -state.position.y * 0.05;

            // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ —É–≥–ª—É
            state.rotationVel = -state.rotation * 0.1;
        }

        // –§–∞–∑–∞ 3: –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–±–ª–∏–∂–µ–Ω–∏–µ –∏ –∑–∞—Ö–≤–∞—Ç (10–º -> 0–º)
        else if (dockingPhase === 3) {
            statusEl.textContent = '–§–ê–ó–ê 3: –ó–ê–•–í–ê–¢';
            statusEl.className = 'status-value docked';

            const targetZ = 0;
            const speed = 0.1;

            if (state.position.z < targetZ - 0.5) {
                state.velocity.z = speed;
            } else {
                state.velocity.z = 0;
                state.velocity.x = 0;
                state.velocity.y = 0;
                dockingPhase = 4;

                setTimeout(() => {
                    statusEl.textContent = '–°–¢–´–ö–û–í–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê!';
                    alert('üéâ –°—Ç—ã–∫–æ–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n' +
                            '–í—Å–µ —ç—Ç–∞–ø—ã –ø—Ä–æ–π–¥–µ–Ω—ã:\n' +
                            '‚úì –§–∞–∑–∞ 1: –°–±–ª–∏–∂–µ–Ω–∏–µ\n' +
                            '‚úì –§–∞–∑–∞ 2: –¢–æ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è\n' +
                            '‚úì –§–∞–∑–∞ 3: –ó–∞—Ö–≤–∞—Ç –∏ –≥–µ—Ä–º–µ—Ç–∏–∑–∞—Ü–∏—è\n\n' +
                            '–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –∫–æ—Ä–∞–±–ª—å —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏—Å—Ç—ã–∫–æ–≤–∞–Ω –∫ –ú–ö–°!');
                }, 1000);
            }

            // –û—á–µ–Ω—å —Ç–æ—á–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è
            state.velocity.x = -state.position.x * 0.1;
            state.velocity.y = -state.position.y * 0.1;
            state.rotationVel = -state.rotation * 0.2;
        }
    }

    function resetSimulation() {
        dockingInProgress = false;
        dockingPhase = 0;
        isPaused = false;

        state = {
            position: {x: 0, y: 0, z: -100},
            velocity: {x: 0, y: 0, z: 0},
            rotation: 0,
            rotationVel: 0,
            fuel: 100,
            status: 'standby'
        };

        document.getElementById('start-btn').disabled = false;
        document.getElementById('start-btn').textContent = 'üöÄ –ù–∞—á–∞—Ç—å —Å—Ç—ã–∫–æ–≤–∫—É';

        document.getElementById('pause-btn').textContent = '‚è∏Ô∏è –ü–∞—É–∑–∞';
        document.getElementById('pause-btn').classList.remove('active');

        const statusEl = document.getElementById('status');
        statusEl.textContent = '–û–ñ–ò–î–ê–ù–ò–ï';
        statusEl.className = 'status-value standby';
    }

    function toggleTheory() {
        const panel = document.getElementById('theory-panel');
        panel.classList.toggle('visible');
        document.getElementById('theory-btn').classList.toggle('active', panel.classList.contains('visible'));
    }

    function updatePhysics(delta) {
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        state.position.x += state.velocity.x * delta * 60;
        state.position.y += state.velocity.y * delta * 60;
        state.position.z += state.velocity.z * delta * 60;
        state.rotation += state.rotationVel * delta * 60;

        // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
        state.velocity.x *= 0.98;
        state.velocity.y *= 0.98;
        state.velocity.z *= 0.98;
        state.rotationVel *= 0.98;

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–æ—Ä–∞–±–ª—è
        spacecraft.position.set(state.position.x, state.position.y, state.position.z);
        spacecraft.rotation.y = state.rotation;

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–ª–µ–º–µ—Ç—Ä–∏–∏
        const distance = Math.sqrt(
                state.position.x ** 2 +
                state.position.y ** 2 +
                state.position.z ** 2
        );
        const velocity = Math.sqrt(
                state.velocity.x ** 2 +
                state.velocity.y ** 2 +
                state.velocity.z ** 2
        );

        document.getElementById('distance').innerHTML = distance.toFixed(1) + '<span class="metric-unit">–º</span>';
        document.getElementById('velocity').innerHTML = velocity.toFixed(2) + '<span class="metric-unit">–º/—Å</span>';
        document.getElementById('angle').innerHTML = (Math.abs(state.rotation * 57.3)).toFixed(1) + '<span class="metric-unit">¬∞</span>';

        // –°–∏–º—É–ª—è—Ü–∏—è —Ä–∞—Å—Ö–æ–¥–∞ —Ç–æ–ø–ª–∏–≤–∞
        if (dockingInProgress) {
            state.fuel = Math.max(0, state.fuel - velocity * 0.05);
        }
        document.getElementById('fuel').innerHTML = state.fuel.toFixed(0) + '<span class="metric-unit">%</span>';

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
        const alignX = Math.max(0, Math.min(100, 100 - Math.abs(state.position.x) * 10));
        const alignY = Math.max(0, Math.min(100, 100 - Math.abs(state.position.y) * 10));
        const alignZ = Math.max(0, Math.min(100, 100 - Math.abs(state.position.z) * 2));

        document.getElementById('align-x').style.width = alignX + '%';
        document.getElementById('align-y').style.width = alignY + '%';
        document.getElementById('align-z').style.width = alignZ + '%';
    }

    let lastTime = 0;

    function animate(currentTime) {
        requestAnimationFrame(animate);

        const delta = (currentTime - lastTime) / 1000 || 0.016;
        lastTime = currentTime;

        // –ü—Ä–æ—Ü–µ—Å—Å —Å—Ç—ã–∫–æ–≤–∫–∏
        updateDocking(delta);

        // –§–∏–∑–∏–∫–∞
        updatePhysics(delta);

        // –ú–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –ú–ö–°
        iss.rotation.y += 0.0001;

        // –ú–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ —Å–æ–ª–Ω–µ—á–Ω—ã—Ö –ø–∞–Ω–µ–ª–µ–π
        if (iss.solarPanels) {
            iss.solarPanels.forEach(panel => {
                panel.rotation.z += 0.0005;
            });
        }

        // –ú–µ—Ä—Ü–∞–Ω–∏–µ –æ–≥–Ω–µ–π –Ω–∞ –∫–æ—Ä–∞–±–ª–µ
        const time = currentTime * 0.001;
        spacecraft.children.forEach(child => {
            if (child.type === 'PointLight') {
                child.intensity = 0.5 + Math.sin(time * 3 + child.position.x * 10) * 0.3;
            }
        });

        // –ú–µ—Ä—Ü–∞–Ω–∏–µ –æ–≥–Ω–µ–π –Ω–∞ –ú–ö–°
        iss.children.forEach(child => {
            if (child.type === 'Group') {
                child.children.forEach(subChild => {
                    if (subChild.type === 'PointLight') {
                        subChild.intensity = 0.8 + Math.sin(time * 2 + subChild.position.x * 5) * 0.4;
                    }
                });
            }
        });

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', onWindowResize);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    window.addEventListener('load', init);
</script>
</body>
</html>