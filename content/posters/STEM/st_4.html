<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–æ–±–æ—Ç-–ú–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä ‚Äî 3D –ú–æ–¥–µ–ª—å</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            color: #e2e8f0;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Header */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            background: linear-gradient(180deg, rgba(15, 23, 42, 0.8) 0%, transparent 100%);
            z-index: 10;
            pointer-events: none;
        }

        .header h1 {
            color: #f97316; /* Orange */
            font-size: 26px;
            font-weight: 700;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(249, 115, 22, 0.5);
        }

        .header p {
            color: #cbd5e1;
            font-size: 14px;
            margin-top: 5px;
        }

        /* Control Panel */
        .control-panel {
            position: absolute;
            top: 100px;
            left: 20px;
            width: 340px;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 24px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #f97316;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }

        .section-title {
            color: #e2e8f0;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 8px;
            margin-top: 20px;
        }

        .section-title:first-child {
            margin-top: 0;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #cbd5e1;
            margin-bottom: 8px;
        }

        .slider-group label span.value {
            color: #f97316;
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        .slider-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            height: 6px;
            border-radius: 3px;
            -webkit-appearance: none;
            background: #475569;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #f8fafc;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            border: 2px solid #f97316;
            transition: transform 0.1s;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #f97316 0%, #c2410c 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #475569;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Checkboxes */
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .checkbox-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .checkbox-item input {
            accent-color: #f97316;
            cursor: pointer;
        }

        .checkbox-item label {
            cursor: pointer;
            font-size: 13px;
            color: #e2e8f0;
            flex: 1;
        }

        /* Info Panel (Right) */
        .info-panel {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(12px);
            border-radius: 12px;
            padding: 20px;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 4px solid #f97316;
        }

        .info-panel h3 {
            color: #f1f5f9;
            font-size: 16px;
            margin: 0 0 15px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            align-items: center;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 13px;
        }

        .stat-value {
            color: #f1f5f9;
            font-weight: 700;
            font-family: 'Consolas', monospace;
            font-size: 14px;
        }

        .hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            color: #fff;
            font-size: 13px;
            pointer-events: none;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div class="header">
    <h1>ü§ñ –†–æ–±–æ—Ç-–ú–∞–Ω–∏–ø—É–ª—è—Ç–æ—Ä</h1>
    <p>–†–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞ ‚Ä¢ –ö–∏–Ω–µ–º–∞—Ç–∏–∫–∞ ‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è</p>
</div>

<div class="control-panel">
    <div class="section-title">üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—É—Å—Ç–∞–≤–∞–º–∏</div>
    <div class="slider-group">
        <label><span>–ë–∞–∑–∞ (Yaw):</span><span class="value" id="val-j1">0¬∞</span></label>
        <input type="range" id="input-j1" min="-180" max="180" value="0">
    </div>
    <div class="slider-group">
        <label><span>–ü–ª–µ—á–æ (Pitch):</span><span class="value" id="val-j2">0¬∞</span></label>
        <input type="range" id="input-j2" min="-45" max="90" value="0">
    </div>
    <div class="slider-group">
        <label><span>–õ–æ–∫–æ—Ç—å (Pitch):</span><span class="value" id="val-j3">45¬∞</span></label>
        <input type="range" id="input-j3" min="-90" max="90" value="45">
    </div>
    <div class="slider-group">
        <label><span>–ó–∞—Ö–≤–∞—Ç:</span><span class="value" id="val-grip">–û—Ç–∫—Ä—ã—Ç</span></label>
        <input type="range" id="input-grip" min="0" max="100" value="0">
    </div>

    <div class="section-title">üöÄ –î–µ–π—Å—Ç–≤–∏—è</div>
    <button class="btn" id="btn-wave">üëã –ü–æ–º–∞—Ö–∞—Ç—å —Ä—É–∫–æ–π</button>
    <button class="btn" id="btn-reset" style="background: #475569;">–°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏</button>

    <div class="section-title">üëÅÔ∏è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</div>
    <div class="checkbox-item">
        <input type="checkbox" id="check-workspace">
        <label for="check-workspace">–†–∞–±–æ—á–∞—è –∑–æ–Ω–∞ (—Å—Ñ–µ—Ä–∞)</label>
    </div>
    <div class="checkbox-item">
        <input type="checkbox" id="check-ik" checked>
        <label for="check-ik">–†–µ–∂–∏–º –∫–ª–∏–∫–∞ (–£–∫–∞–∑–∞—Ç—å —Ç–æ—á–∫—É)</label>
    </div>
</div>

<div class="info-panel">
    <h3>üìä –°—Ç–∞—Ç—É—Å</h3>
    <div class="stat-row">
        <span class="stat-label">–†–µ–∂–∏–º:</span>
        <span class="stat-value" id="stat-mode" style="color:#f97316">–†–£–ß–ù–û–ô</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">–≠—Ñ—Ñ–µ–∫—Ç–æ—Ä X:</span>
        <span class="stat-value" id="stat-x">0 —Å–º</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">–≠—Ñ—Ñ–µ–∫—Ç–æ—Ä Y:</span>
        <span class="stat-value" id="stat-y">0 —Å–º</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">–≠—Ñ—Ñ–µ–∫—Ç–æ—Ä Z:</span>
        <span class="stat-value" id="stat-z">0 —Å–º</span>
    </div>
</div>

<div class="hint">–õ–ö–ú - –í—Ä–∞—â–µ–Ω–∏–µ ‚Ä¢ –ü–ö–ú - –ü–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –ö–ª–∏–∫ –ø–æ —Å—Ç–æ–ª—É - –†–æ–±–æ—Ç –∫–æ—Å–Ω–µ—Ç—Å—è —ç—Ç–æ–π —Ç–æ—á–∫–∏</div>

<!-- Three.js -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // --- Configuration ---
    const CONFIG = {
        baseRadius: 7.5,
        arm1Len: 20,
        arm2Len: 15,
        gripperLen: 7.5, // Exact distance from wrist joint center to finger tips
        colorBase: 0x475569, // Lighter grey
        colorServo1: 0xf97316, // Orange
        colorServo2: 0x1e293b, // Black
        colorServo3: 0x2563eb, // Blue
        colorAlu: 0xe2e8f0,    // Brighter Silver
        colorGripper: 0x1e293b
    };

    // --- State ---
    let state = {
        j1: 0, // Yaw
        j2: 0, // Shoulder
        j3: 45, // Elbow
        grip: 0, // 0 = open, 100 = closed
        isAnimating: false
    };

    // --- Globals ---
    let scene, camera, renderer, controls;
    // Parts
    let baseGroup, turretGroup, arm1Group, arm2Group, wristGroup, gripperL, gripperR;
    let workspaceMesh;
    let ikTargetHelper;

    // --- Initialization ---
    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e293b); // Lighter background
        // Reduced fog density significantly so scene is bright
        scene.fog = new THREE.FogExp2(0x1e293b, 0.002);

        // Camera
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 500);
        camera.position.set(50, 60, 70);
        camera.lookAt(0, 10, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // Enable tone mapping for better brightness
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- LIGHTING (BRIGHTER) ---
        // 1. Ambient Light (Base brightness)
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        // 2. Hemisphere Light (Sky/Ground mix)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        // 3. Directional Light (Sun - Shadows)
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.8);
        dirLight.position.set(30, 60, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        // 4. Fill Light (Opposite side)
        const fillLight = new THREE.DirectionalLight(0xdbeafe, 0.8);
        fillLight.position.set(-30, 20, -30);
        scene.add(fillLight);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.02; // Prevent going below floor
        controls.minDistance = 20;
        controls.maxDistance = 200;

        // Build Scene
        createEnvironment();
        createRobot();
        createWorkspaceViz();

        // Listeners
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousedown', onMouseDown, false);
        setupUI();

        // Start
        animate();
        updateRobotPose();
    }

    // --- Scene Construction ---

    function createEnvironment() {
        // Table (Lighter Wood)
        const tableGeo = new THREE.BoxGeometry(80, 3, 60);
        const tableMat = new THREE.MeshStandardMaterial({color: 0xd4a373, roughness: 0.6});
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.position.y = -1.5;
        table.receiveShadow = true;
        scene.add(table);

        // Grid (Subtle)
        const grid = new THREE.GridHelper(80, 20, 0x000000, 0x000000);
        grid.position.y = 0.01;
        grid.material.opacity = 0.1;
        grid.material.transparent = true;
        scene.add(grid);

        // IK Target Marker
        const sphereGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const sphereMat = new THREE.MeshBasicMaterial({color: 0x22c55e, transparent: true, opacity: 0.8});
        ikTargetHelper = new THREE.Mesh(sphereGeo, sphereMat);
        ikTargetHelper.visible = false;
        scene.add(ikTargetHelper);
    }

    function createRobot() {
        // 1. BASE (Static)
        baseGroup = new THREE.Group();
        scene.add(baseGroup);

        const baseGeo = new THREE.CylinderGeometry(CONFIG.baseRadius, CONFIG.baseRadius, 4, 32);
        const baseMat = new THREE.MeshStandardMaterial({color: CONFIG.colorBase, roughness: 0.5, metalness: 0.2});
        const baseMesh = new THREE.Mesh(baseGeo, baseMat);
        baseMesh.position.y = 2;
        baseMesh.castShadow = true;
        baseMesh.receiveShadow = true;
        baseGroup.add(baseMesh);

        // Power LED
        const ledGeo = new THREE.CircleGeometry(0.5, 16);
        const ledMat = new THREE.MeshBasicMaterial({color: 0x22c55e});
        const led = new THREE.Mesh(ledGeo, ledMat);
        led.rotation.x = -Math.PI / 2;
        led.position.set(CONFIG.baseRadius - 2, 4.01, 0);
        baseGroup.add(led);

        // 2. TURRET (Joint 1 - Yaw)
        turretGroup = new THREE.Group();
        turretGroup.position.y = 4; // Top of base
        baseGroup.add(turretGroup);

        // Servo 1
        const servo1Geo = new THREE.BoxGeometry(5, 4, 5);
        const servo1Mat = new THREE.MeshStandardMaterial({color: CONFIG.colorServo1, roughness: 0.3});
        const servo1 = new THREE.Mesh(servo1Geo, servo1Mat);
        servo1.position.y = 2;
        servo1.castShadow = true;
        turretGroup.add(servo1);

        // Bracket
        const bracketGeo = new THREE.BoxGeometry(4, 4, 4);
        const bracketMat = new THREE.MeshStandardMaterial({color: 0x1e293b, roughness: 0.5});
        const bracket = new THREE.Mesh(bracketGeo, bracketMat);
        bracket.position.y = 5;
        turretGroup.add(bracket);

        // 3. ARM 1 (Joint 2 - Shoulder Pitch)
        // Pivot point at center of bracket
        arm1Group = new THREE.Group();
        arm1Group.position.y = 5;
        turretGroup.add(arm1Group);

        // Segment 1 Mesh
        const arm1Geo = new THREE.BoxGeometry(3, CONFIG.arm1Len, 2);
        const aluMat = new THREE.MeshStandardMaterial({color: CONFIG.colorAlu, metalness: 0.7, roughness: 0.2});
        const arm1Mesh = new THREE.Mesh(arm1Geo, aluMat);
        // Pivot is at bottom of arm, so shift geometry up
        arm1Mesh.position.y = CONFIG.arm1Len / 2;
        arm1Mesh.castShadow = true;
        arm1Group.add(arm1Mesh);

        // Servo 2 (Elbow Motor)
        const servo2Geo = new THREE.BoxGeometry(4, 4, 3);
        const servo2Mat = new THREE.MeshStandardMaterial({color: CONFIG.colorServo2});
        const servo2 = new THREE.Mesh(servo2Geo, servo2Mat);
        servo2.position.y = CONFIG.arm1Len;
        arm1Group.add(servo2);

        // 4. ARM 2 (Joint 3 - Elbow Pitch)
        arm2Group = new THREE.Group();
        arm2Group.position.y = CONFIG.arm1Len;
        arm1Group.add(arm2Group);

        // Segment 2 Mesh
        const arm2Geo = new THREE.BoxGeometry(2.5, CONFIG.arm2Len, 1.5);
        const arm2Mesh = new THREE.Mesh(arm2Geo, aluMat);
        arm2Mesh.position.y = CONFIG.arm2Len / 2;
        arm2Mesh.castShadow = true;
        arm2Group.add(arm2Mesh);

        // Servo 3 (Wrist)
        const servo3Geo = new THREE.BoxGeometry(3, 3, 3);
        const servo3Mat = new THREE.MeshStandardMaterial({color: CONFIG.colorServo3});
        const servo3 = new THREE.Mesh(servo3Geo, servo3Mat);
        servo3.position.y = CONFIG.arm2Len;
        arm2Group.add(servo3);

        // 5. WRIST / GRIPPER
        wristGroup = new THREE.Group();
        wristGroup.position.y = CONFIG.arm2Len;
        arm2Group.add(wristGroup);

        // Gripper Base
        const gripBaseGeo = new THREE.BoxGeometry(4, 1, 2);
        const gripMat = new THREE.MeshStandardMaterial({color: CONFIG.colorGripper});
        const gripBase = new THREE.Mesh(gripBaseGeo, gripMat);
        gripBase.position.y = 1.5;
        wristGroup.add(gripBase);

        // Fingers
        const fingerGeo = new THREE.BoxGeometry(0.5, 6, 1);

        // Left Finger
        gripperL = new THREE.Mesh(fingerGeo, gripMat);
        gripperL.position.set(-1.5, 3 + 1.5, 0);
        wristGroup.add(gripperL);

        // Right Finger
        gripperR = new THREE.Mesh(fingerGeo, gripMat);
        gripperR.position.set(1.5, 3 + 1.5, 0);
        wristGroup.add(gripperR);
    }

    function createWorkspaceViz() {
        const radius = CONFIG.arm1Len + CONFIG.arm2Len;
        const geometry = new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI * 0.5);
        const material = new THREE.MeshBasicMaterial({
            color: 0x38bdf8,
            transparent: true,
            opacity: 0.1,
            wireframe: true
        });
        workspaceMesh = new THREE.Mesh(geometry, material);
        workspaceMesh.position.y = 4 + 5; // Base height + bracket offset
        workspaceMesh.visible = false;
        scene.add(workspaceMesh);
    }

    // --- Kinematics ---

    function updateRobotPose() {
        // Convert deg to rad
        const r1 = THREE.MathUtils.degToRad(state.j1);
        const r2 = THREE.MathUtils.degToRad(state.j2);
        const r3 = THREE.MathUtils.degToRad(state.j3);

        // Apply rotations
        turretGroup.rotation.y = r1;
        arm1Group.rotation.z = r2;
        arm2Group.rotation.z = r3;

        // Gripper
        const maxOffset = 1.5;
        const minOffset = 0.3;
        const currentOffset = maxOffset - (state.grip / 100) * (maxOffset - minOffset);

        gripperL.position.x = -currentOffset;
        gripperR.position.x = currentOffset;

        // Update EE position stat (Forward Kinematics)
        const eePos = new THREE.Vector3();
        // The real tip is offset from wrist group
        // Wrist group is at servo axis. Gripper tips are ~7.5 units up (local Y)
        const tipLocal = new THREE.Vector3(0, CONFIG.gripperLen, 0);
        const tipWorld = tipLocal.applyMatrix4(wristGroup.matrixWorld);

        document.getElementById('stat-x').textContent = Math.round(tipWorld.x) + ' —Å–º';
        document.getElementById('stat-y').textContent = Math.round(tipWorld.y) + ' —Å–º';
        document.getElementById('stat-z').textContent = Math.round(tipWorld.z) + ' —Å–º';
    }

    // --- Inverse Kinematics (Simple 2D planar + Yaw) ---
    function solveIK(targetX, targetY, targetZ) {
        // We calculate for the wrist joint (Joint 3).
        // Since we have a 3DOF arm, we cannot control the pitch of the end effector independently.
        // The gripper is a fixed extension of Arm 2.
        // So, the total length of the second segment is L2 + L_gripper.

        const L1 = CONFIG.arm1Len;
        const L2_total = CONFIG.arm2Len + CONFIG.gripperLen; // Effective length of forearm

        // 1. Yaw
        const yaw = Math.atan2(targetX, targetZ);

        // 2. Planar IK (Project to 2D plane)
        const dist = Math.sqrt(targetX * targetX + targetZ * targetZ);
        const shoulderY = 9; // Height of shoulder pivot

        const dy = targetY - shoulderY;
        const dx = dist;

        const h = Math.sqrt(dx * dx + dy * dy);

        if (h > L1 + L2_total) return null; // Unreachable

        // Law of Cosines
        // alpha: angle of hypotenuse vs horizon
        const alpha = Math.atan2(dy, dx);

        // beta: angle of L1 vs hypotenuse
        const cosBeta = (L1 * L1 + h * h - L2_total * L2_total) / (2 * L1 * h);
        // Clamp to avoid NaN due to float errors
        const beta = Math.acos(Math.max(-1, Math.min(1, cosBeta)));

        const theta1_rad = (Math.PI / 2) - (alpha + beta);

        // gamma: internal angle at elbow
        const cosGamma = (L1 * L1 + L2_total * L2_total - h * h) / (2 * L1 * L2_total);
        const gamma = Math.acos(Math.max(-1, Math.min(1, cosGamma)));
        const theta2_rad = Math.PI - gamma;

        return {
            j1: THREE.MathUtils.radToDeg(yaw),
            j2: THREE.MathUtils.radToDeg(theta1_rad),
            j3: THREE.MathUtils.radToDeg(theta2_rad)
        };
    }

    // --- Interaction ---
    function onMouseDown(event) {
        if (!document.getElementById('check-ik').checked) return;
        if (state.isAnimating) return;
        if (event.target.closest('.control-panel')) return;

        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(scene.children, true);

        for (let hit of intersects) {
            // Valid click surface? (Table or Box)
            const isTable = hit.object.geometry && hit.object.geometry.type === 'BoxGeometry';

            if (isTable) {
                const target = hit.point;
                // Clamp target Y so we don't try to go underground
                target.y = Math.max(target.y, 0);

                // Place marker
                ikTargetHelper.position.copy(target);
                ikTargetHelper.visible = true;

                // Solve for this specific point
                const sol = solveIK(target.x, target.y, target.z);

                if (sol) {
                    animateToPose(sol.j1, sol.j2, sol.j3, 800);
                } else {
                    // Visual feedback for unreachable?
                    ikTargetHelper.material.color.setHex(0xff0000); // Red
                    setTimeout(() => ikTargetHelper.material.color.setHex(0x22c55e), 200);
                }
                break;
            }
        }
    }

    function animateToPose(tJ1, tJ2, tJ3, duration) {
        state.isAnimating = true;
        const start = {j1: state.j1, j2: state.j2, j3: state.j3};
        const end = {j1: tJ1, j2: tJ2, j3: tJ3};

        const startTime = Date.now();

        return new Promise(resolve => {
            function loop() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                // Smooth easing
                const ease = progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                state.j1 = start.j1 + (end.j1 - start.j1) * ease;
                state.j2 = start.j2 + (end.j2 - start.j2) * ease;
                state.j3 = start.j3 + (end.j3 - start.j3) * ease;

                document.getElementById('input-j1').value = state.j1;
                document.getElementById('input-j2').value = state.j2;
                document.getElementById('input-j3').value = state.j3;
                updateLabels();
                updateRobotPose();

                if (progress < 1) {
                    requestAnimationFrame(loop);
                } else {
                    state.isAnimating = false;
                    // Keep marker visible to show we arrived
                    resolve();
                }
            }

            loop();
        });
    }

    function runWaveRoutine() {
        if (state.isAnimating) return;
        document.getElementById('stat-mode').innerText = "–ê–í–¢–û: –ü–†–ò–í–ï–¢!";

        (async () => {
            await animateToPose(0, -20, -45, 1000);
            for (let i = 0; i < 3; i++) {
                await animateToPose(0, -20, -10, 300);
                await animateToPose(0, -20, -60, 300);
            }
            await animateToPose(0, 0, 45, 1000);
            document.getElementById('stat-mode').innerText = "–†–£–ß–ù–û–ô";
        })();
    }

    // --- UI Setup ---
    function setupUI() {
        const updateVal = (id, val, suffix) => document.getElementById(id).textContent = Math.round(val) + suffix;

        document.getElementById('input-j1').addEventListener('input', (e) => {
            state.j1 = parseFloat(e.target.value);
            updateVal('val-j1', state.j1, '¬∞');
            updateRobotPose();
        });
        document.getElementById('input-j2').addEventListener('input', (e) => {
            state.j2 = parseFloat(e.target.value);
            updateVal('val-j2', state.j2, '¬∞');
            updateRobotPose();
        });
        document.getElementById('input-j3').addEventListener('input', (e) => {
            state.j3 = parseFloat(e.target.value);
            updateVal('val-j3', state.j3, '¬∞');
            updateRobotPose();
        });
        document.getElementById('input-grip').addEventListener('input', (e) => {
            state.grip = parseFloat(e.target.value);
            document.getElementById('val-grip').textContent = state.grip + '%';
            updateRobotPose();
        });

        document.getElementById('btn-wave').addEventListener('click', runWaveRoutine);

        document.getElementById('btn-reset').addEventListener('click', () => {
            animateToPose(0, 0, 45, 1000);
            state.grip = 0;
            document.getElementById('input-grip').value = 0;
            ikTargetHelper.visible = false;
        });

        document.getElementById('check-workspace').addEventListener('change', (e) => {
            workspaceMesh.visible = e.target.checked;
        });
    }

    function updateLabels() {
        document.getElementById('val-j1').textContent = Math.round(state.j1) + '¬∞';
        document.getElementById('val-j2').textContent = Math.round(state.j2) + '¬∞';
        document.getElementById('val-j3').textContent = Math.round(state.j3) + '¬∞';
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // Start
    init();

</script>
</body>
</html>