<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –í–µ—Ç—Ä—è–Ω–∞—è –¢—É—Ä–±–∏–Ω–∞ - –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –ú–æ–¥–µ–ª—å</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px 30px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, transparent 100%);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .title span {
            color: #4ade80;
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .control-panel {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            width: 280px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4ade80;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title::before {
            content: '‚öôÔ∏è';
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            color: #4ade80;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(74, 222, 128, 0.5);
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .toggle-btn {
            width: 100%;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .toggle-btn.primary {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
        }

        .toggle-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.4);
        }

        .toggle-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #f97316, #ea580c);
        }

        /* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å */
        .info-panel {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            width: 260px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .info-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #60a5fa;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-title::before {
            content: 'üìä';
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
        }

        .stat-value.power {
            color: #4ade80;
        }

        .stat-value.rpm {
            color: #60a5fa;
        }

        .stat-value.efficiency {
            color: #fbbf24;
        }

        /* –§–æ—Ä–º—É–ª–∞ */
        .formula-box {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            text-align: center;
        }

        .formula {
            font-size: 16px;
            font-family: 'Times New Roman', serif;
            color: #fbbf24;
        }

        .formula-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 8px;
        }

        /* –õ–µ–≥–µ–Ω–¥–∞ */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 15px 25px;
            display: flex;
            gap: 30px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–µ—Ç—Ä–∞ */
        .wind-indicator {
            position: fixed;
            top: 100px;
            right: 30px;
            text-align: center;
            z-index: 100;
        }

        .wind-arrow {
            font-size: 48px;
            animation: windPulse 2s ease-in-out infinite;
        }

        @keyframes windPulse {
            0%, 100% {
                transform: translateX(0);
                opacity: 1;
            }
            50% {
                transform: translateX(-10px);
                opacity: 0.7;
            }
        }

        .wind-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        /* –ó–∞–≥—Ä—É–∑–∫–∞ */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: #4ade80;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∏ */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 200;
            max-width: 200px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .control-panel, .info-panel {
                width: 220px;
                padding: 20px;
            }
        }

        @media (max-width: 900px) {
            .control-panel {
                left: 10px;
                width: 200px;
            }

            .info-panel {
                right: 10px;
                width: 200px;
            }
        }
    </style>
</head>
<body>
<div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">–ó–∞–≥—Ä—É–∑–∫–∞ 3D –º–æ–¥–µ–ª–∏...</div>
</div>

<div id="canvas-container"></div>

<div class="header">
    <div>
        <div class="title">–í–µ—Ç—Ä—è–Ω–∞—è <span>–¢—É—Ä–±–∏–Ω–∞</span></div>
        <div class="subtitle">–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è 3D –º–æ–¥–µ–ª—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —ç–Ω–µ—Ä–≥–∏–∏</div>
    </div>
</div>

<div class="control-panel">
    <div class="panel-title">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</div>

    <div class="control-group">
        <div class="control-label">
            <span>–°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞</span>
            <span class="control-value" id="wind-value">10 –º/—Å</span>
        </div>
        <input type="range" id="wind-speed" min="0" max="25" value="10" step="0.5">
    </div>

    <div class="control-group">
        <div class="control-label">
            <span>–£–≥–æ–ª –ª–æ–ø–∞—Å—Ç–µ–π</span>
            <span class="control-value" id="pitch-value">15¬∞</span>
        </div>
        <input type="range" id="blade-pitch" min="0" max="45" value="15" step="1">
    </div>

    <div class="control-group">
        <button class="toggle-btn secondary" id="cutaway-btn" onclick="toggleCutaway()">
            üîç –ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞–∑—Ä–µ–∑
        </button>
    </div>

    <div class="control-group">
        <button class="toggle-btn secondary" id="wind-btn" onclick="toggleWindFlow()">
            üí® –ü–æ—Ç–æ–∫ –≤–æ–∑–¥—É—Ö–∞
        </button>
    </div>

    <div class="control-group">
        <button class="toggle-btn secondary" id="labels-btn" onclick="toggleLabels()">
            üè∑Ô∏è –ü–æ–¥–ø–∏—Å–∏
        </button>
    </div>

    <div class="control-group">
        <button class="toggle-btn primary" onclick="resetView()">
            üîÑ –°–±—Ä–æ—Å–∏—Ç—å –≤–∏–¥
        </button>
    </div>
</div>

<div class="info-panel">
    <div class="info-title">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</div>

    <div class="stat-item">
        <span class="stat-label">–ú–æ—â–Ω–æ—Å—Ç—å</span>
        <span class="stat-value power" id="power-output">500 –í—Ç</span>
    </div>

    <div class="stat-item">
        <span class="stat-label">–û–±–æ—Ä–æ—Ç—ã —Ä–æ—Ç–æ—Ä–∞</span>
        <span class="stat-value rpm" id="rpm-value">18 –æ–±/–º–∏–Ω</span>
    </div>

    <div class="stat-item">
        <span class="stat-label">–ö–ü–î —Ç—É—Ä–±–∏–Ω—ã</span>
        <span class="stat-value efficiency" id="efficiency-value">42%</span>
    </div>

    <div class="stat-item">
        <span class="stat-label">–î–∏–∞–º–µ—Ç—Ä —Ä–æ—Ç–æ—Ä–∞</span>
        <span class="stat-value">40 —Å–º</span>
    </div>

    <div class="stat-item">
        <span class="stat-label">–í—ã—Å–æ—Ç–∞ –±–∞—à–Ω–∏</span>
        <span class="stat-value">40 —Å–º</span>
    </div>

    <div class="formula-box">
        <div class="formula">P = ¬ΩœÅAv¬≥C‚Çö</div>
        <div class="formula-desc">œÅ ‚Äî –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –≤–æ–∑–¥—É—Ö–∞, A ‚Äî –ø–ª–æ—â–∞–¥—å, v ‚Äî —Å–∫–æ—Ä–æ—Å—Ç—å, C‚Çö ‚Äî –∫–æ—ç—Ñ—Ñ. –º–æ—â–Ω–æ—Å—Ç–∏</div>
    </div>
</div>

<div class="wind-indicator">
    <div class="wind-arrow">üí®</div>
    <div class="wind-label">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç—Ä–∞</div>
</div>

<div class="legend">
    <div class="legend-item">
        <div class="legend-color" style="background: #f8f8f8;"></div>
        <span>–ë–∞—à–Ω—è –∏ –ª–æ–ø–∞—Å—Ç–∏</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #d97706;"></div>
        <span>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä (–º–µ–¥—å)</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #64748b;"></div>
        <span>–†–µ–¥—É–∫—Ç–æ—Ä</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: #60a5fa;"></div>
        <span>–ü–æ—Ç–æ–∫ –≤–æ–∑–¥—É—Ö–∞</span>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    let scene, camera, renderer, controls;
    let turbine = {};
    let windParticles = [];
    let labels = [];
    let rotorSpeed = 0;
    let targetRotorSpeed = 0;
    let windSpeed = 10;
    let bladePitch = 15;
    let showCutaway = false;
    let showWindFlow = false;
    let showLabels = false;
    let cutawayMaterials = [];
    let originalMaterials = [];

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    function init() {
        // –°—Ü–µ–Ω–∞
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 50, 150);

        // –ö–∞–º–µ—Ä–∞
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(35, 25, 35);
        camera.lookAt(0, 15, 0);

        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        setupLighting();

        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—É—Ä–±–∏–Ω—ã
        createTurbine();

        // –°–æ–∑–¥–∞–Ω–∏–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        createEnvironment();

        // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤–µ—Ç—Ä–∞
        createWindParticles();

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–µ–π
        createLabels();

        // –û—Ä–±–∏—Ç–∞–ª—å–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª—ã (–ø—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è)
        setupControls();

        // –°–æ–±—ã—Ç–∏—è
        window.addEventListener('resize', onWindowResize);
        setupUIEvents();

        // –ê–Ω–∏–º–∞—Ü–∏—è
        animate();

        // –°–∫—Ä—ã—Ç—å –∑–∞–≥—Ä—É–∑–∫—É
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 1000);
    }

    function setupLighting() {
        // –û—Å–Ω–æ–≤–Ω–æ–π –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç (—Å–æ–ª–Ω—Ü–µ)
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(30, 50, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);

        // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
        const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
        fillLight.position.set(-20, 30, -10);
        scene.add(fillLight);

        // –ê–º–±–∏–µ–Ω—Ç–Ω—ã–π —Å–≤–µ—Ç
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        // –ü–æ–ª—É—Å—Ñ–µ—Ä–∏—á–µ—Å–∫–∏–π —Å–≤–µ—Ç
        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3a5f3a, 0.5);
        scene.add(hemiLight);
    }

    function createTurbine() {
        const turbineGroup = new THREE.Group();

        // === –§–£–ù–î–ê–ú–ï–ù–¢ ===
        const foundationGeom = new THREE.CylinderGeometry(5, 6, 2, 8);
        const concreteMat = new THREE.MeshStandardMaterial({
            color: 0x808080,
            roughness: 0.9,
            metalness: 0.1
        });
        const foundation = new THREE.Mesh(foundationGeom, concreteMat);
        foundation.position.y = 1;
        foundation.castShadow = true;
        foundation.receiveShadow = true;
        turbineGroup.add(foundation);
        turbine.foundation = foundation;

        // –ë–æ–ª—Ç—ã –Ω–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–µ
        for (let i = 0; i < 8; i++) {
            const boltGeom = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
            const boltMat = new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3});
            const bolt = new THREE.Mesh(boltGeom, boltMat);
            const angle = (i / 8) * Math.PI * 2;
            bolt.position.set(Math.cos(angle) * 4, 2.3, Math.sin(angle) * 4);
            turbineGroup.add(bolt);
        }

        // === –ë–ê–®–ù–Ø ===
        const towerGeom = new THREE.CylinderGeometry(1.2, 1.8, 40, 32);
        const towerMat = new THREE.MeshStandardMaterial({
            color: 0xf0f0f0,
            roughness: 0.4,
            metalness: 0.3
        });
        const tower = new THREE.Mesh(towerGeom, towerMat);
        tower.position.y = 22;
        tower.castShadow = true;
        tower.receiveShadow = true;
        turbineGroup.add(tower);
        turbine.tower = tower;

        // –°–µ–≥–º–µ–Ω—Ç—ã –±–∞—à–Ω–∏ (–≤–∏–∑—É–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏)
        for (let i = 0; i < 8; i++) {
            const segmentRing = new THREE.Mesh(
                    new THREE.TorusGeometry(1.5 - i * 0.05, 0.05, 8, 32),
                    new THREE.MeshStandardMaterial({color: 0xcccccc, roughness: 0.5})
            );
            segmentRing.rotation.x = Math.PI / 2;
            segmentRing.position.y = 5 + i * 5;
            turbineGroup.add(segmentRing);
        }

        // –î–≤–µ—Ä—å –Ω–∞ –±–∞—à–Ω–µ
        const doorGeom = new THREE.BoxGeometry(1, 2.5, 0.1);
        const doorMat = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.5, roughness: 0.5});
        const door = new THREE.Mesh(doorGeom, doorMat);
        door.position.set(0, 3.5, 1.8);
        turbineGroup.add(door);

        // === –ì–û–ù–î–û–õ–ê (NACELLE) ===
        const nacelleGroup = new THREE.Group();
        nacelleGroup.position.y = 42;

        // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å –≥–æ–Ω–¥–æ–ª—ã (—Å–æ–∑–¥–∞—ë–º –≤—Ä—É—á–Ω—É—é –∏–∑ —Ü–∏–ª–∏–Ω–¥—Ä–∞ –∏ –ø–æ–ª—É—Å—Ñ–µ—Ä)
        const nacelleBodyGeom = new THREE.CylinderGeometry(2, 2, 8, 32);
        const nacelleMat = new THREE.MeshStandardMaterial({
            color: 0xe8e8e8,
            roughness: 0.3,
            metalness: 0.2
        });
        const nacelleBody = new THREE.Mesh(nacelleBodyGeom, nacelleMat);
        nacelleBody.rotation.z = Math.PI / 2;
        nacelleBody.position.x = 2;
        nacelleBody.castShadow = true;
        nacelleGroup.add(nacelleBody);

        // –ü–µ—Ä–µ–¥–Ω—è—è –ø–æ–ª—É—Å—Ñ–µ—Ä–∞ –≥–æ–Ω–¥–æ–ª—ã
        const nacelleFrontGeom = new THREE.SphereGeometry(2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const nacelleFront = new THREE.Mesh(nacelleFrontGeom, nacelleMat);
        nacelleFront.rotation.z = -Math.PI / 2;
        nacelleFront.position.x = -2;
        nacelleGroup.add(nacelleFront);

        // –ó–∞–¥–Ω—è—è –ø–æ–ª—É—Å—Ñ–µ—Ä–∞ –≥–æ–Ω–¥–æ–ª—ã
        const nacelleBackGeom = new THREE.SphereGeometry(2, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const nacelleBack = new THREE.Mesh(nacelleBackGeom, nacelleMat);
        nacelleBack.rotation.z = Math.PI / 2;
        nacelleBack.position.x = 6;
        nacelleGroup.add(nacelleBack);

        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é
        const nacelle = new THREE.Group();
        nacelle.add(nacelleBody.clone());
        turbine.nacelle = nacelleBody;
        turbine.nacelleParts = [nacelleBody, nacelleFront, nacelleBack];

        // –ê–Ω–µ–º–æ–º–µ—Ç—Ä (–¥–∞—Ç—á–∏–∫ –≤–µ—Ç—Ä–∞)
        const anemometerBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8),
                new THREE.MeshStandardMaterial({color: 0x666666, metalness: 0.7})
        );
        anemometerBase.position.set(4, 2.5, 0);
        nacelleGroup.add(anemometerBase);

        // –ß–∞—à–∫–∏ –∞–Ω–µ–º–æ–º–µ—Ç—Ä–∞
        const anemometerCups = new THREE.Group();
        for (let i = 0; i < 3; i++) {
            const cupArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
                    new THREE.MeshStandardMaterial({color: 0x444444})
            );
            cupArm.rotation.z = Math.PI / 2;
            const cup = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 8, 0, Math.PI),
                    new THREE.MeshStandardMaterial({color: 0x333333})
            );
            cup.position.x = 0.5;
            cup.rotation.y = Math.PI / 2;

            const cupGroup = new THREE.Group();
            cupGroup.add(cupArm);
            cupGroup.add(cup);
            cupGroup.rotation.y = (i / 3) * Math.PI * 2;
            anemometerCups.add(cupGroup);
        }
        anemometerCups.position.set(4, 3.3, 0);
        nacelleGroup.add(anemometerCups);
        turbine.anemometer = anemometerCups;

        // –°–∏–≥–Ω–∞–ª—å–Ω—ã–π –æ–≥–æ–Ω—å
        const warningLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                })
        );
        warningLight.position.set(4, 2, 0);
        nacelleGroup.add(warningLight);
        turbine.warningLight = warningLight;

        // === –í–ù–£–¢–†–ï–ù–ù–ò–ï –ö–û–ú–ü–û–ù–ï–ù–¢–´ ===
        const internalsGroup = new THREE.Group();
        internalsGroup.visible = false;

        // –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä
        const generatorGeom = new THREE.CylinderGeometry(1.2, 1.2, 4, 32);
        const generatorMat = new THREE.MeshStandardMaterial({
            color: 0xd97706,
            roughness: 0.4,
            metalness: 0.8
        });
        const generator = new THREE.Mesh(generatorGeom, generatorMat);
        generator.rotation.z = Math.PI / 2;
        generator.position.x = 3;
        internalsGroup.add(generator);
        turbine.generator = generator;

        // –ö–∞—Ç—É—à–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
        for (let i = 0; i < 8; i++) {
            const coilGeom = new THREE.TorusGeometry(0.8, 0.15, 8, 16);
            const coilMat = new THREE.MeshStandardMaterial({
                color: 0xb45309,
                roughness: 0.3,
                metalness: 0.9
            });
            const coil = new THREE.Mesh(coilGeom, coilMat);
            coil.position.x = 1.5 + i * 0.35;
            coil.rotation.y = Math.PI / 2;
            internalsGroup.add(coil);
        }

        // –†–µ–¥—É–∫—Ç–æ—Ä
        const gearboxGeom = new THREE.BoxGeometry(2, 1.5, 2);
        const gearboxMat = new THREE.MeshStandardMaterial({
            color: 0x64748b,
            roughness: 0.3,
            metalness: 0.7
        });
        const gearbox = new THREE.Mesh(gearboxGeom, gearboxMat);
        gearbox.position.x = 0;
        internalsGroup.add(gearbox);
        turbine.gearbox = gearbox;

        // –®–µ—Å—Ç–µ—Ä–Ω–∏
        const gearGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
        const gearMat = new THREE.MeshStandardMaterial({color: 0x475569, metalness: 0.8, roughness: 0.2});

        const gear1 = new THREE.Mesh(gearGeom, gearMat);
        gear1.position.set(-0.3, 0, 0);
        gear1.rotation.z = Math.PI / 2;
        internalsGroup.add(gear1);
        turbine.gear1 = gear1;

        const gear2 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.3, 0.3, 16),
                gearMat
        );
        gear2.position.set(0.3, 0, 0);
        gear2.rotation.z = Math.PI / 2;
        internalsGroup.add(gear2);
        turbine.gear2 = gear2;

        // –ü—Ä–∏–≤–æ–¥–Ω–æ–π –≤–∞–ª
        const shaftGeom = new THREE.CylinderGeometry(0.2, 0.2, 5, 16);
        const shaftMat = new THREE.MeshStandardMaterial({color: 0x555555, metalness: 0.7, roughness: 0.3});
        const shaft = new THREE.Mesh(shaftGeom, shaftMat);
        shaft.rotation.z = Math.PI / 2;
        shaft.position.x = -2;
        internalsGroup.add(shaft);
        turbine.shaft = shaft;

        nacelleGroup.add(internalsGroup);
        turbine.internals = internalsGroup;

        turbineGroup.add(nacelleGroup);
        turbine.nacelleGroup = nacelleGroup;

        // === –†–û–¢–û–† (–õ–û–ü–ê–°–¢–ò) ===
        const rotorGroup = new THREE.Group();
        rotorGroup.position.set(-4.5, 42, 0);

        // –°—Ç—É–ø–∏—Ü–∞
        const hubGeom = new THREE.SphereGeometry(1.2, 32, 32);
        const hubMat = new THREE.MeshStandardMaterial({
            color: 0x555555,
            roughness: 0.4,
            metalness: 0.6
        });
        const hub = new THREE.Mesh(hubGeom, hubMat);
        rotorGroup.add(hub);

        // –ù–æ—Å–æ–≤–æ–π –∫–æ–Ω—É—Å
        const noseGeom = new THREE.ConeGeometry(1, 3, 32);
        const noseMat = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.3,
            metalness: 0.5
        });
        const nose = new THREE.Mesh(noseGeom, noseMat);
        nose.rotation.z = Math.PI / 2;
        nose.position.x = -2;
        rotorGroup.add(nose);

        // –õ–æ–ø–∞—Å—Ç–∏
        const bladeMat = new THREE.MeshStandardMaterial({
            color: 0xfafafa,
            roughness: 0.25,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        for (let i = 0; i < 3; i++) {
            const blade = createBlade();
            blade.rotation.x = (i / 3) * Math.PI * 2;
            rotorGroup.add(blade);
        }

        turbineGroup.add(rotorGroup);
        turbine.rotor = rotorGroup;

        // === –ö–ê–ë–ï–õ–¨ ===
        const cableGeom = new THREE.CylinderGeometry(0.15, 0.15, 40, 8);
        const cableMat = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.8});
        const cable = new THREE.Mesh(cableGeom, cableMat);
        cable.position.set(1.5, 22, 0);
        turbineGroup.add(cable);

        // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ç–æ—Ä–Ω–∞—è –±—É–¥–∫–∞
        const transformerGeom = new THREE.BoxGeometry(3, 2, 2);
        const transformerMat = new THREE.MeshStandardMaterial({color: 0x666666, roughness: 0.7, metalness: 0.3});
        const transformer = new THREE.Mesh(transformerGeom, transformerMat);
        transformer.position.set(6, 1, 0);
        transformer.castShadow = true;
        transformer.receiveShadow = true;
        turbineGroup.add(transformer);

        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–∞–±–æ—Ç—ã (LED)
        const ledGeom = new THREE.SphereGeometry(0.2, 16, 16);
        const ledMat = new THREE.MeshStandardMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 1
        });
        const led = new THREE.Mesh(ledGeom, ledMat);
        led.position.set(6, 2.2, 1.1);
        turbineGroup.add(led);
        turbine.led = led;

        scene.add(turbineGroup);
        turbine.group = turbineGroup;
    }

    function createBlade() {
        const bladeGroup = new THREE.Group();

        const bladeLength = 18;

        // –õ–æ–ø–∞—Å—Ç—å –≤—ã—Ç—è–Ω—É—Ç–∞ –≤–¥–æ–ª—å Y (—Ä–∞–¥–∏–∞–ª—å–Ω–æ –æ—Ç —Å—Ç—É–ø–∏—Ü—ã)
        // –®–∏—Ä–∏–Ω–∞ –ø–æ Z (–ø—Ä–æ—Ñ–∏–ª—å), —Ç–æ–ª—â–∏–Ω–∞ –ø–æ X
        const bladeGeom = new THREE.BoxGeometry(0.4, bladeLength, 2.5);

        // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –≤–µ—Ä—à–∏–Ω—ã –¥–ª—è –∞—ç—Ä–æ–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–π —Ñ–æ—Ä–º—ã
        const positions = bladeGeom.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            const z = positions.getZ(i);

            // –ü–∞—Ä–∞–º–µ—Ç—Ä t: 0 —É –∫–æ—Ä–Ω—è, 1 –Ω–∞ –∫–æ–Ω—á–∏–∫–µ
            const t = (y + bladeLength / 2) / bladeLength;

            // –°—É–∂–µ–Ω–∏–µ –æ—Ç –∫–æ—Ä–Ω—è –∫ –∫–æ–Ω—á–∏–∫—É
            const taper = 1 - t * 0.75;
            positions.setZ(i, z * taper);

            // –ù–µ–±–æ–ª—å—à–æ–π —Ç–≤–∏—Å—Ç –ª–æ–ø–∞—Å—Ç–∏ (—É–≥–æ–ª –∞—Ç–∞–∫–∏ –º–µ–Ω—è–µ—Ç—Å—è)
            const twist = t * 0.15;
            const newX = positions.getX(i) * Math.cos(twist) - z * taper * Math.sin(twist) * 0.1;
            positions.setX(i, newX);
        }
        bladeGeom.computeVertexNormals();

        const bladeMat = new THREE.MeshStandardMaterial({
            color: 0xf8f8f8,
            roughness: 0.25,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const blade = new THREE.Mesh(bladeGeom, bladeMat);
        blade.position.y = bladeLength / 2 + 1.2; // –°–º–µ—â–µ–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ —Å—Ç—É–ø–∏—Ü—ã
        blade.castShadow = true;
        blade.receiveShadow = true;

        bladeGroup.add(blade);

        // –ö–æ—Ä–µ–Ω—å –ª–æ–ø–∞—Å—Ç–∏ (–∫—Ä–µ–ø–ª–µ–Ω–∏–µ –∫ —Å—Ç—É–ø–∏—Ü–µ)
        const rootGeom = new THREE.CylinderGeometry(0.6, 0.5, 1.5, 16);
        const rootMat = new THREE.MeshStandardMaterial({
            color: 0x555555,
            metalness: 0.6,
            roughness: 0.4
        });
        const root = new THREE.Mesh(rootGeom, rootMat);
        root.position.y = 0.9;
        bladeGroup.add(root);

        return bladeGroup;
    }

    function createEnvironment() {
        // –ó–µ–º–ª—è (—Ç—Ä–∞–≤–∞)
        const groundGeom = new THREE.CircleGeometry(80, 64);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x3a5f3a,
            roughness: 0.9,
            metalness: 0
        });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // –•–æ–ª–º—ã –Ω–∞ –∑–∞–¥–Ω–µ–º –ø–ª–∞–Ω–µ
        for (let i = 0; i < 5; i++) {
            const hillGeom = new THREE.SphereGeometry(15 + Math.random() * 10, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hillMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.3, 0.3, 0.25 + Math.random() * 0.1),
                roughness: 0.9
            });
            const hill = new THREE.Mesh(hillGeom, hillMat);
            const angle = (i / 5) * Math.PI - Math.PI / 2;
            hill.position.set(Math.cos(angle) * 60, 0, Math.sin(angle) * 60 - 30);
            hill.receiveShadow = true;
            scene.add(hill);
        }

        // –û–±–ª–∞–∫–∞
        for (let i = 0; i < 8; i++) {
            const cloudGroup = new THREE.Group();
            const cloudMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.7,
                roughness: 1
            });

            for (let j = 0; j < 5; j++) {
                const puffGeom = new THREE.SphereGeometry(2 + Math.random() * 2, 16, 16);
                const puff = new THREE.Mesh(puffGeom, cloudMat);
                puff.position.set(
                        (Math.random() - 0.5) * 6,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 3
                );
                cloudGroup.add(puff);
            }

            cloudGroup.position.set(
                    (Math.random() - 0.5) * 100,
                    50 + Math.random() * 30,
                    -30 + (Math.random() - 0.5) * 40
            );
            scene.add(cloudGroup);
        }
    }

    function createWindParticles() {
        const particleCount = 200;
        const particleGeom = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 80 - 20;
            positions[i * 3 + 1] = Math.random() * 60 + 5;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 40;

            velocities.push({
                x: 0.5 + Math.random() * 0.3,
                y: (Math.random() - 0.5) * 0.1,
                z: (Math.random() - 0.5) * 0.2
            });
        }

        particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const particleMat = new THREE.PointsMaterial({
            color: 0x60a5fa,
            size: 0.5,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particleGeom, particleMat);
        particles.visible = false;
        scene.add(particles);

        turbine.windParticles = particles;
        turbine.windVelocities = velocities;
    }

    function createLabels() {
        // –ü–æ–¥–ø–∏—Å–∏ —Å–æ–∑–¥–∞—é—Ç—Å—è –∫–∞–∫ HTML —ç–ª–µ–º–µ–Ω—Ç—ã —Å CSS 3D –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è–º–∏
        const labelsData = [
            {text: '–õ–æ–ø–∞—Å—Ç—å (20 —Å–º)', position: new THREE.Vector3(-15, 52, 0)},
            {text: '–ì–æ–Ω–¥–æ–ª–∞', position: new THREE.Vector3(8, 45, 0)},
            {text: '–ë–∞—à–Ω—è (40 —Å–º)', position: new THREE.Vector3(5, 25, 0)},
            {text: '–§—É–Ω–¥–∞–º–µ–Ω—Ç', position: new THREE.Vector3(8, 3, 0)},
            {text: '–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä', position: new THREE.Vector3(12, 42, 0)},
            {text: '–°—Ç—É–ø–∏—Ü–∞', position: new THREE.Vector3(-8, 45, 0)}
        ];

        labelsData.forEach(data => {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label-3d';
            labelDiv.textContent = data.text;
            labelDiv.style.cssText = `
                    position: fixed;
                    color: white;
                    font-size: 12px;
                    background: rgba(0,0,0,0.7);
                    padding: 5px 10px;
                    border-radius: 5px;
                    pointer-events: none;
                    display: none;
                    white-space: nowrap;
                    z-index: 50;
                `;
            document.body.appendChild(labelDiv);
            labels.push({element: labelDiv, position: data.position});
        });
    }

    function setupControls() {
        let isDragging = false;
        let previousMousePosition = {x: 0, y: 0};
        let cameraAngle = {theta: Math.PI / 4, phi: Math.PI / 6};
        let cameraRadius = 55;

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = {x: e.clientX, y: e.clientY};
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            cameraAngle.theta -= deltaX * 0.005;
            cameraAngle.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngle.phi + deltaY * 0.005));

            updateCameraPosition();
            previousMousePosition = {x: e.clientX, y: e.clientY};
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraRadius = Math.max(25, Math.min(100, cameraRadius + e.deltaY * 0.05));
            updateCameraPosition();
        });

        function updateCameraPosition() {
            camera.position.x = cameraRadius * Math.sin(cameraAngle.theta) * Math.cos(cameraAngle.phi);
            camera.position.y = cameraRadius * Math.sin(cameraAngle.phi) + 20;
            camera.position.z = cameraRadius * Math.cos(cameraAngle.theta) * Math.cos(cameraAngle.phi);
            camera.lookAt(0, 20, 0);
        }

        window.resetView = function () {
            cameraAngle = {theta: Math.PI / 4, phi: Math.PI / 6};
            cameraRadius = 55;
            updateCameraPosition();
        };
    }

    function setupUIEvents() {
        // –°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞
        document.getElementById('wind-speed').addEventListener('input', (e) => {
            windSpeed = parseFloat(e.target.value);
            document.getElementById('wind-value').textContent = windSpeed.toFixed(1) + ' –º/—Å';
            updatePowerOutput();
        });

        // –£–≥–æ–ª –ª–æ–ø–∞—Å—Ç–µ–π
        document.getElementById('blade-pitch').addEventListener('input', (e) => {
            bladePitch = parseFloat(e.target.value);
            document.getElementById('pitch-value').textContent = bladePitch + '¬∞';
            updatePowerOutput();
        });
    }

    function toggleCutaway() {
        showCutaway = !showCutaway;
        const btn = document.getElementById('cutaway-btn');
        btn.classList.toggle('active', showCutaway);
        btn.innerHTML = showCutaway ? 'üîç –°–∫—Ä—ã—Ç—å —Ä–∞–∑—Ä–µ–∑' : 'üîç –ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞–∑—Ä–µ–∑';

        turbine.internals.visible = showCutaway;

        if (turbine.nacelleParts) {
            turbine.nacelleParts.forEach(part => {
                if (showCutaway) {
                    part.material.transparent = true;
                    part.material.opacity = 0.3;
                } else {
                    part.material.transparent = false;
                    part.material.opacity = 1;
                }
            });
        }
    }

    function toggleWindFlow() {
        showWindFlow = !showWindFlow;
        const btn = document.getElementById('wind-btn');
        btn.classList.toggle('active', showWindFlow);
        btn.innerHTML = showWindFlow ? 'üí® –°–∫—Ä—ã—Ç—å –ø–æ—Ç–æ–∫' : 'üí® –ü–æ—Ç–æ–∫ –≤–æ–∑–¥—É—Ö–∞';

        turbine.windParticles.visible = showWindFlow;
    }

    function toggleLabels() {
        showLabels = !showLabels;
        const btn = document.getElementById('labels-btn');
        btn.classList.toggle('active', showLabels);
        btn.innerHTML = showLabels ? 'üè∑Ô∏è –°–∫—Ä—ã—Ç—å –ø–æ–¥–ø–∏—Å–∏' : 'üè∑Ô∏è –ü–æ–¥–ø–∏—Å–∏';

        labels.forEach(label => {
            label.element.style.display = showLabels ? 'block' : 'none';
        });
    }

    function updatePowerOutput() {
        // –§–æ—Ä–º—É–ª–∞ –º–æ—â–Ω–æ—Å—Ç–∏: P = 0.5 * rho * A * v^3 * Cp
        const rho = 1.225; // –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –≤–æ–∑–¥—É—Ö–∞ –∫–≥/–º¬≥
        const radius = 0.2; // —Ä–∞–¥–∏—É—Å —Ä–æ—Ç–æ—Ä–∞ –≤ –º–µ—Ç—Ä–∞—Ö (–º–æ–¥–µ–ª—å)
        const A = Math.PI * radius * radius;
        const Cp = 0.35 + (bladePitch / 100) * 0.1; // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –º–æ—â–Ω–æ—Å—Ç–∏

        let power = 0.5 * rho * A * Math.pow(windSpeed, 3) * Cp;
        power = Math.max(0, power * 100); // –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è

        // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø—Ä–∏ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π/–º–∞–ª–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤–µ—Ç—Ä–∞
        if (windSpeed < 3) power = 0;
        if (windSpeed > 25) power *= 0.5;

        const rpm = Math.max(0, (windSpeed - 2) * 3);
        const efficiency = windSpeed > 3 ? 35 + Math.random() * 10 : 0;

        document.getElementById('power-output').textContent = power.toFixed(0) + ' –í—Ç';
        document.getElementById('rpm-value').textContent = rpm.toFixed(0) + ' –æ–±/–º–∏–Ω';
        document.getElementById('efficiency-value').textContent = efficiency.toFixed(0) + '%';

        targetRotorSpeed = windSpeed > 3 ? windSpeed * 0.02 : 0;
    }

    function updateWindParticles() {
        if (!turbine.windParticles.visible) return;

        const positions = turbine.windParticles.geometry.attributes.position.array;
        const velocities = turbine.windVelocities;
        const speedFactor = windSpeed / 10;

        for (let i = 0; i < velocities.length; i++) {
            positions[i * 3] += velocities[i].x * speedFactor;
            positions[i * 3 + 1] += velocities[i].y * speedFactor;
            positions[i * 3 + 2] += velocities[i].z * speedFactor;

            // –°–±—Ä–æ—Å —á–∞—Å—Ç–∏—Ü
            if (positions[i * 3] > 40) {
                positions[i * 3] = -40;
                positions[i * 3 + 1] = Math.random() * 60 + 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
            }
        }

        turbine.windParticles.geometry.attributes.position.needsUpdate = true;
    }

    function updateLabels() {
        if (!showLabels) return;

        labels.forEach(label => {
            const screenPosition = label.position.clone();
            screenPosition.project(camera);

            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;

            label.element.style.left = x + 'px';
            label.element.style.top = y + 'px';
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Ä–æ—Ç–æ—Ä–∞
        rotorSpeed += (targetRotorSpeed - rotorSpeed) * 0.02;

        // –í—Ä–∞—â–µ–Ω–∏–µ —Ä–æ—Ç–æ—Ä–∞
        if (turbine.rotor) {
            turbine.rotor.rotation.x += rotorSpeed;
        }

        // –í—Ä–∞—â–µ–Ω–∏–µ –∞–Ω–µ–º–æ–º–µ—Ç—Ä–∞
        if (turbine.anemometer) {
            turbine.anemometer.rotation.y += rotorSpeed * 2;
        }

        // –í—Ä–∞—â–µ–Ω–∏–µ —à–µ—Å—Ç–µ—Ä–Ω–µ–π
        if (turbine.gear1 && turbine.internals.visible) {
            turbine.gear1.rotation.x += rotorSpeed * 0.5;
            turbine.gear2.rotation.x -= rotorSpeed * 1.5;
        }

        // –ú–∏–≥–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ –æ–≥–Ω—è
        if (turbine.warningLight) {
            const pulse = (Math.sin(Date.now() * 0.003) + 1) * 0.5;
            turbine.warningLight.material.emissiveIntensity = 0.3 + pulse * 0.7;
        }

        // –ú–∏–≥–∞–Ω–∏–µ LED –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
        if (turbine.led && windSpeed > 3) {
            const pulse = (Math.sin(Date.now() * 0.01) + 1) * 0.5;
            turbine.led.material.emissiveIntensity = 0.5 + pulse * 0.5;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤–µ—Ç—Ä–∞
        updateWindParticles();

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–µ–π
        updateLabels();

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // –ó–∞–ø—É—Å–∫
    init();
    updatePowerOutput();
</script>
</body>
</html>